#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <Windows.h>
#include "plusaes.hpp"
#include "IceKey.h"

#define PIPE_FILE L"\\\\.\\pipe\\ROPP"

struct ROP // ROP struct
{
public:
	DWORD magic = 0x524f5050; // ROPP
	// We use AES CFB
	unsigned char aes_iv[16] = {};
	unsigned char aes_key[16] = {};
	size_t targ = 0xBAADF00DBAADF00D; // idx for target func array

	void init(unsigned char* aes_iv, unsigned char* aes_key, size_t targ);
};

void ROP::init(unsigned char* aes_iv, unsigned char* aes_key, size_t targ) {
	for (int i = 0; i < 16; i++) {
		this->aes_iv[i] = aes_iv[i];
		this->aes_key[i] = aes_key[i];
	}
	this->targ = targ;
}

HANDLE recv_ropp(ROP* rop, LPCWSTR pipe_name) {
	HANDLE pipe = CreateFile(
		pipe_name,
		GENERIC_READ | GENERIC_WRITE,
		0,
		0,
		OPEN_EXISTING,
		0,
		NULL
	);
	if (pipe == INVALID_HANDLE_VALUE) {
		return 0;
	}
	if (ReadFile(pipe, rop, sizeof(ROP), NULL, NULL)) {
		return pipe;
	}
	return 0;
}

HANDLE send_ropp(ROP* rop, LPCWSTR pipe_name) { // it also remain
	HANDLE pipe = CreateNamedPipe(
		pipe_name,
		PIPE_ACCESS_DUPLEX,
		PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,
		1,
		1024,
		1024,
		NMPWAIT_WAIT_FOREVER,
		NULL
	);

	if (pipe == INVALID_HANDLE_VALUE) {
		return 0;
	}

	if (!ConnectNamedPipe(pipe, NULL)) {
		CloseHandle(pipe);
		return 0;
	}

	if (WriteFile(pipe, rop, sizeof(ROP), NULL, NULL)) {
		return pipe;
	}
	return 0;
}

struct ROPRESPONSE {
	DWORD magic = 0x69697474;
	unsigned char flag[32] = {};
	bool invalid = false;
};

typedef DWORD(WINAPI* PFZWQUERYINFORMATIONPROCESS) (
	HANDLE ProcessHandle,
	DWORD ProcessInformationClass,
	PVOID ProcessInformation,
	ULONG ProcessInformationLength,
	PULONG ReturnLength
	);

void exit_with_sending(ROPRESPONSE* rr, HANDLE rr_handle) {
	WriteFile(rr_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
	exit(1);
}

void exit_with_invalid(ROPRESPONSE* rr, HANDLE rr_handle) {
	for (int i = 0; i < 32; i++) { rr->flag[i] = 0xee; }
	rr->invalid = true;
	exit_with_sending(rr, rr_handle);
}

void init_aes_0(ROP* rop_handle) {
	unsigned char aes_key[16] = { 109, 119, 57, 143, 32, 234, 139, 146, 228, 246, 5, 252, 109, 34, 41, 135, };
	unsigned char aes_iv[16] = { 156, 193, 114, 138, 249, 156, 52, 132, 161, 8, 115, 189, 179, 238, 114, 60, };
	rop_handle->init(aes_iv, aes_key, 70);
}
void init_aes_1(ROP* rop_handle) {
	unsigned char aes_key[16] = { 23, 215, 123, 125, 192, 161, 105, 248, 223, 67, 219, 53, 6, 184, 238, 240, };
	unsigned char aes_iv[16] = { 195, 111, 141, 24, 234, 128, 170, 182, 216, 16, 41, 0, 174, 228, 215, 148, };
	rop_handle->init(aes_iv, aes_key, 33);
}
void init_aes_2(ROP* rop_handle) {
	unsigned char aes_key[16] = { 125, 176, 74, 10, 199, 120, 103, 110, 206, 178, 92, 145, 86, 105, 241, 220, };
	unsigned char aes_iv[16] = { 188, 219, 204, 82, 61, 177, 124, 2, 113, 18, 115, 75, 245, 223, 186, 4, };
	rop_handle->init(aes_iv, aes_key, 31);
}
void init_aes_3(ROP* rop_handle) {
	unsigned char aes_key[16] = { 104, 217, 250, 26, 229, 254, 61, 198, 63, 213, 30, 133, 58, 183, 127, 207, };
	unsigned char aes_iv[16] = { 62, 199, 154, 120, 92, 102, 229, 66, 74, 19, 197, 246, 224, 88, 151, 1, };
	rop_handle->init(aes_iv, aes_key, 26);
}
void init_aes_4(ROP* rop_handle) {
	unsigned char aes_key[16] = { 232, 165, 186, 62, 206, 99, 135, 179, 11, 149, 68, 155, 209, 220, 108, 214, };
	unsigned char aes_iv[16] = { 238, 92, 161, 84, 36, 37, 154, 58, 104, 181, 250, 208, 95, 19, 67, 221, };
	rop_handle->init(aes_iv, aes_key, 75);
}
void init_aes_5(ROP* rop_handle) {
	unsigned char aes_key[16] = { 115, 26, 198, 75, 32, 179, 80, 181, 6, 172, 183, 124, 107, 212, 99, 2, };
	unsigned char aes_iv[16] = { 138, 177, 24, 135, 227, 253, 232, 112, 28, 139, 79, 69, 4, 185, 106, 213, };
	rop_handle->init(aes_iv, aes_key, 71);
}
void init_aes_6(ROP* rop_handle) {
	unsigned char aes_key[16] = { 202, 226, 253, 167, 24, 227, 226, 126, 216, 119, 125, 42, 213, 122, 85, 253, };
	unsigned char aes_iv[16] = { 198, 133, 253, 178, 136, 76, 21, 130, 2, 174, 106, 122, 245, 227, 171, 219, };
	rop_handle->init(aes_iv, aes_key, 64);
}
void init_aes_7(ROP* rop_handle) {
	unsigned char aes_key[16] = { 164, 59, 221, 204, 176, 147, 111, 105, 147, 40, 197, 71, 165, 125, 231, 5, };
	unsigned char aes_iv[16] = { 155, 130, 119, 235, 18, 108, 70, 40, 15, 228, 249, 145, 3, 215, 84, 32, };
	rop_handle->init(aes_iv, aes_key, 43);
}
void init_aes_8(ROP* rop_handle) {
	unsigned char aes_key[16] = { 148, 7, 9, 168, 61, 41, 221, 210, 137, 100, 229, 237, 141, 253, 66, 109, };
	unsigned char aes_iv[16] = { 227, 107, 66, 21, 208, 70, 18, 130, 162, 207, 47, 56, 209, 31, 191, 113, };
	rop_handle->init(aes_iv, aes_key, 3);
}
void init_aes_9(ROP* rop_handle) {
	unsigned char aes_key[16] = { 124, 10, 47, 244, 120, 71, 41, 230, 139, 185, 60, 133, 18, 157, 115, 235, };
	unsigned char aes_iv[16] = { 180, 86, 25, 195, 105, 96, 167, 127, 197, 123, 48, 26, 150, 139, 16, 119, };
	rop_handle->init(aes_iv, aes_key, 6);
}
void init_aes_10(ROP* rop_handle) {
	unsigned char aes_key[16] = { 21, 240, 89, 126, 245, 83, 182, 107, 101, 195, 157, 231, 110, 29, 115, 176, };
	unsigned char aes_iv[16] = { 106, 245, 150, 246, 80, 209, 202, 241, 43, 128, 144, 222, 100, 146, 255, 101, };
	rop_handle->init(aes_iv, aes_key, 18);
}
void init_aes_11(ROP* rop_handle) {
	unsigned char aes_key[16] = { 226, 106, 66, 102, 30, 197, 103, 191, 9, 138, 110, 134, 170, 92, 20, 149, };
	unsigned char aes_iv[16] = { 72, 196, 150, 174, 45, 196, 151, 4, 130, 76, 14, 124, 224, 209, 246, 203, };
	rop_handle->init(aes_iv, aes_key, 15);
}
void init_aes_12(ROP* rop_handle) {
	unsigned char aes_key[16] = { 249, 31, 224, 88, 222, 87, 66, 227, 77, 4, 1, 7, 224, 254, 102, 156, };
	unsigned char aes_iv[16] = { 132, 216, 31, 188, 119, 60, 218, 229, 134, 229, 225, 11, 97, 115, 9, 13, };
	rop_handle->init(aes_iv, aes_key, 24);
}
void init_aes_13(ROP* rop_handle) {
	unsigned char aes_key[16] = { 66, 91, 6, 98, 66, 135, 169, 110, 136, 155, 154, 47, 232, 46, 4, 115, };
	unsigned char aes_iv[16] = { 137, 11, 57, 224, 146, 169, 147, 144, 137, 1, 242, 240, 128, 144, 116, 196, };
	rop_handle->init(aes_iv, aes_key, 30);
}
void init_aes_14(ROP* rop_handle) {
	unsigned char aes_key[16] = { 51, 168, 3, 164, 78, 107, 107, 200, 215, 242, 106, 193, 130, 73, 148, 33, };
	unsigned char aes_iv[16] = { 230, 180, 220, 149, 232, 2, 96, 64, 129, 186, 82, 250, 15, 52, 130, 24, };
	rop_handle->init(aes_iv, aes_key, 68);
}
void init_aes_15(ROP* rop_handle) {
	unsigned char aes_key[16] = { 197, 109, 10, 250, 141, 167, 179, 192, 184, 151, 118, 78, 155, 78, 195, 11, };
	unsigned char aes_iv[16] = { 231, 234, 205, 73, 28, 133, 238, 233, 234, 245, 29, 162, 120, 132, 214, 139, };
	rop_handle->init(aes_iv, aes_key, 54);
}
void init_aes_16(ROP* rop_handle) {
	unsigned char aes_key[16] = { 76, 128, 19, 190, 27, 80, 64, 94, 195, 198, 36, 95, 219, 102, 156, 130, };
	unsigned char aes_iv[16] = { 41, 225, 14, 144, 100, 113, 43, 184, 146, 173, 27, 187, 9, 107, 7, 44, };
	rop_handle->init(aes_iv, aes_key, 86);
}
void init_aes_17(ROP* rop_handle) {
	unsigned char aes_key[16] = { 63, 132, 140, 157, 117, 62, 228, 252, 107, 43, 14, 75, 203, 225, 60, 191, };
	unsigned char aes_iv[16] = { 4, 15, 82, 156, 39, 237, 132, 48, 48, 139, 26, 41, 93, 170, 223, 170, };
	rop_handle->init(aes_iv, aes_key, 40);
}
void init_aes_18(ROP* rop_handle) {
	unsigned char aes_key[16] = { 244, 182, 80, 105, 86, 21, 150, 37, 11, 82, 220, 95, 78, 151, 216, 181, };
	unsigned char aes_iv[16] = { 192, 245, 85, 246, 29, 21, 77, 117, 231, 144, 164, 148, 0, 147, 150, 91, };
	rop_handle->init(aes_iv, aes_key, 95);
}
void init_aes_19(ROP* rop_handle) {
	unsigned char aes_key[16] = { 49, 5, 187, 193, 244, 0, 159, 160, 23, 1, 59, 121, 246, 227, 132, 77, };
	unsigned char aes_iv[16] = { 225, 253, 231, 38, 240, 234, 61, 1, 108, 241, 145, 125, 48, 223, 50, 8, };
	rop_handle->init(aes_iv, aes_key, 28);
}
void init_aes_20(ROP* rop_handle) {
	unsigned char aes_key[16] = { 205, 7, 204, 221, 82, 93, 40, 238, 37, 179, 216, 127, 188, 209, 180, 236, };
	unsigned char aes_iv[16] = { 249, 137, 60, 213, 12, 203, 151, 241, 187, 107, 3, 166, 159, 98, 132, 251, };
	rop_handle->init(aes_iv, aes_key, 58);
}
void init_aes_21(ROP* rop_handle) {
	unsigned char aes_key[16] = { 207, 69, 75, 224, 172, 245, 233, 183, 30, 202, 55, 99, 178, 239, 14, 253, };
	unsigned char aes_iv[16] = { 31, 230, 101, 73, 234, 126, 99, 13, 126, 238, 169, 45, 71, 76, 62, 178, };
	rop_handle->init(aes_iv, aes_key, 82);
}
void init_aes_22(ROP* rop_handle) {
	unsigned char aes_key[16] = { 178, 159, 147, 175, 114, 75, 215, 246, 204, 56, 83, 54, 8, 138, 143, 40, };
	unsigned char aes_iv[16] = { 123, 4, 111, 55, 68, 12, 150, 129, 65, 201, 112, 221, 44, 147, 166, 251, };
	rop_handle->init(aes_iv, aes_key, 9);
}
void init_aes_23(ROP* rop_handle) {
	unsigned char aes_key[16] = { 48, 143, 152, 52, 83, 137, 78, 32, 254, 192, 115, 195, 55, 106, 125, 222, };
	unsigned char aes_iv[16] = { 157, 34, 164, 141, 103, 11, 207, 164, 89, 6, 56, 229, 231, 60, 26, 146, };
	rop_handle->init(aes_iv, aes_key, 74);
}
void init_aes_24(ROP* rop_handle) {
	unsigned char aes_key[16] = { 18, 173, 192, 238, 215, 69, 8, 22, 211, 161, 133, 15, 35, 67, 61, 93, };
	unsigned char aes_iv[16] = { 236, 24, 2, 102, 218, 135, 90, 242, 180, 79, 225, 0, 64, 181, 37, 52, };
	rop_handle->init(aes_iv, aes_key, 14);
}
void init_aes_25(ROP* rop_handle) {
	unsigned char aes_key[16] = { 192, 17, 205, 127, 250, 187, 44, 186, 181, 36, 181, 48, 221, 81, 139, 90, };
	unsigned char aes_iv[16] = { 13, 224, 173, 54, 137, 168, 105, 129, 72, 93, 155, 146, 101, 73, 248, 100, };
	rop_handle->init(aes_iv, aes_key, 76);
}
void init_aes_26(ROP* rop_handle) {
	unsigned char aes_key[16] = { 135, 91, 124, 44, 196, 89, 37, 30, 177, 186, 50, 185, 139, 233, 249, 86, };
	unsigned char aes_iv[16] = { 207, 113, 218, 115, 45, 141, 205, 133, 165, 107, 58, 109, 99, 52, 66, 39, };
	rop_handle->init(aes_iv, aes_key, 78);
}
void init_aes_27(ROP* rop_handle) {
	unsigned char aes_key[16] = { 11, 143, 111, 165, 91, 247, 94, 6, 194, 196, 65, 14, 227, 149, 202, 37, };
	unsigned char aes_iv[16] = { 255, 20, 209, 117, 246, 188, 55, 124, 102, 244, 239, 55, 107, 70, 174, 167, };
	rop_handle->init(aes_iv, aes_key, 47);
}
void init_aes_28(ROP* rop_handle) {
	unsigned char aes_key[16] = { 88, 201, 150, 215, 241, 133, 252, 155, 2, 249, 179, 125, 83, 42, 118, 178, };
	unsigned char aes_iv[16] = { 213, 71, 77, 85, 214, 180, 131, 101, 102, 17, 134, 63, 193, 235, 123, 53, };
	rop_handle->init(aes_iv, aes_key, 80);
}
void init_aes_29(ROP* rop_handle) {
	unsigned char aes_key[16] = { 134, 61, 229, 41, 45, 104, 29, 204, 114, 166, 214, 136, 253, 99, 190, 110, };
	unsigned char aes_iv[16] = { 207, 214, 59, 85, 176, 94, 57, 229, 206, 48, 125, 119, 29, 186, 59, 55, };
	rop_handle->init(aes_iv, aes_key, 59);
}
void init_aes_30(ROP* rop_handle) {
	unsigned char aes_key[16] = { 100, 131, 10, 189, 76, 247, 210, 214, 7, 202, 68, 101, 140, 1, 211, 92, };
	unsigned char aes_iv[16] = { 34, 46, 48, 39, 169, 174, 211, 26, 247, 174, 97, 52, 51, 11, 52, 30, };
	rop_handle->init(aes_iv, aes_key, 52);
}
void init_aes_31(ROP* rop_handle) {
	unsigned char aes_key[16] = { 188, 13, 135, 155, 25, 231, 158, 17, 131, 238, 148, 177, 50, 62, 243, 131, };
	unsigned char aes_iv[16] = { 85, 48, 170, 252, 167, 209, 231, 215, 180, 93, 197, 174, 115, 119, 229, 202, };
	rop_handle->init(aes_iv, aes_key, 21);
}
void init_aes_32(ROP* rop_handle) {
	unsigned char aes_key[16] = { 168, 223, 11, 100, 119, 126, 114, 189, 210, 80, 252, 9, 113, 66, 178, 59, };
	unsigned char aes_iv[16] = { 180, 72, 101, 138, 212, 128, 136, 239, 195, 188, 206, 30, 38, 82, 174, 47, };
	rop_handle->init(aes_iv, aes_key, 45);
}
void init_aes_33(ROP* rop_handle) {
	unsigned char aes_key[16] = { 28, 109, 151, 46, 242, 247, 223, 249, 15, 12, 181, 33, 190, 76, 69, 3, };
	unsigned char aes_iv[16] = { 248, 120, 146, 127, 190, 148, 107, 113, 233, 210, 44, 42, 93, 87, 208, 188, };
	rop_handle->init(aes_iv, aes_key, 79);
}
void init_aes_34(ROP* rop_handle) {
	unsigned char aes_key[16] = { 47, 52, 186, 53, 184, 85, 197, 96, 100, 199, 41, 134, 28, 225, 225, 11, };
	unsigned char aes_iv[16] = { 177, 138, 108, 216, 88, 171, 143, 88, 238, 0, 172, 56, 181, 233, 137, 8, };
	rop_handle->init(aes_iv, aes_key, 19);
}
void init_aes_35(ROP* rop_handle) {
	unsigned char aes_key[16] = { 17, 176, 53, 0, 85, 199, 157, 199, 128, 154, 77, 57, 48, 124, 17, 115, };
	unsigned char aes_iv[16] = { 70, 28, 137, 255, 228, 56, 136, 86, 190, 214, 135, 220, 72, 164, 250, 220, };
	rop_handle->init(aes_iv, aes_key, 85);
}
void init_aes_36(ROP* rop_handle) {
	unsigned char aes_key[16] = { 136, 178, 243, 14, 91, 20, 38, 197, 18, 205, 136, 249, 66, 14, 29, 106, };
	unsigned char aes_iv[16] = { 187, 128, 2, 87, 219, 16, 33, 161, 127, 169, 9, 200, 84, 223, 21, 191, };
	rop_handle->init(aes_iv, aes_key, 25);
}
void init_aes_37(ROP* rop_handle) {
	unsigned char aes_key[16] = { 162, 196, 179, 75, 86, 227, 242, 213, 44, 112, 130, 115, 245, 223, 242, 201, };
	unsigned char aes_iv[16] = { 98, 51, 57, 143, 158, 240, 88, 163, 97, 98, 132, 110, 209, 56, 100, 139, };
	rop_handle->init(aes_iv, aes_key, 94);
}
void init_aes_38(ROP* rop_handle) {
	unsigned char aes_key[16] = { 209, 90, 208, 99, 182, 104, 26, 12, 10, 194, 184, 187, 139, 41, 236, 238, };
	unsigned char aes_iv[16] = { 92, 200, 156, 68, 86, 148, 153, 75, 4, 117, 158, 143, 49, 46, 120, 167, };
	rop_handle->init(aes_iv, aes_key, 91);
}
void init_aes_39(ROP* rop_handle) {
	unsigned char aes_key[16] = { 108, 162, 221, 223, 49, 249, 144, 108, 30, 236, 20, 14, 11, 38, 97, 165, };
	unsigned char aes_iv[16] = { 225, 171, 104, 178, 155, 58, 56, 89, 238, 13, 8, 124, 234, 178, 134, 100, };
	rop_handle->init(aes_iv, aes_key, 46);
}
void init_aes_40(ROP* rop_handle) {
	unsigned char aes_key[16] = { 134, 225, 75, 157, 143, 8, 61, 18, 226, 137, 229, 155, 143, 174, 18, 94, };
	unsigned char aes_iv[16] = { 90, 122, 94, 155, 56, 106, 11, 253, 146, 233, 119, 95, 162, 117, 207, 182, };
	rop_handle->init(aes_iv, aes_key, 44);
}
void init_aes_41(ROP* rop_handle) {
	unsigned char aes_key[16] = { 47, 134, 155, 246, 3, 121, 157, 240, 74, 211, 229, 2, 159, 146, 130, 14, };
	unsigned char aes_iv[16] = { 234, 200, 222, 94, 164, 34, 187, 43, 57, 63, 122, 39, 45, 182, 235, 224, };
	rop_handle->init(aes_iv, aes_key, 12);
}
void init_aes_42(ROP* rop_handle) {
	unsigned char aes_key[16] = { 138, 109, 92, 248, 202, 160, 159, 79, 75, 205, 179, 255, 50, 168, 178, 67, };
	unsigned char aes_iv[16] = { 209, 186, 51, 143, 54, 93, 71, 193, 113, 254, 78, 38, 233, 36, 136, 41, };
	rop_handle->init(aes_iv, aes_key, 53);
}
void init_aes_43(ROP* rop_handle) {
	unsigned char aes_key[16] = { 254, 116, 4, 34, 109, 212, 88, 167, 50, 182, 103, 154, 161, 149, 2, 163, };
	unsigned char aes_iv[16] = { 134, 4, 62, 162, 168, 18, 202, 175, 61, 39, 117, 129, 137, 187, 181, 152, };
	rop_handle->init(aes_iv, aes_key, 27);
}
void init_aes_44(ROP* rop_handle) {
	unsigned char aes_key[16] = { 56, 103, 255, 117, 162, 16, 95, 178, 137, 12, 240, 66, 110, 81, 19, 212, };
	unsigned char aes_iv[16] = { 18, 124, 184, 87, 27, 73, 234, 97, 171, 232, 10, 125, 176, 72, 136, 142, };
	rop_handle->init(aes_iv, aes_key, 42);
}
void init_aes_45(ROP* rop_handle) {
	unsigned char aes_key[16] = { 69, 30, 217, 183, 210, 127, 5, 137, 128, 173, 158, 182, 170, 197, 50, 202, };
	unsigned char aes_iv[16] = { 26, 191, 242, 150, 191, 57, 135, 225, 36, 34, 253, 176, 148, 128, 228, 239, };
	rop_handle->init(aes_iv, aes_key, 77);
}
void init_aes_46(ROP* rop_handle) {
	unsigned char aes_key[16] = { 176, 50, 209, 157, 181, 67, 13, 112, 245, 206, 188, 150, 143, 103, 240, 57, };
	unsigned char aes_iv[16] = { 173, 221, 123, 15, 232, 180, 217, 145, 213, 198, 92, 78, 19, 213, 42, 38, };
	rop_handle->init(aes_iv, aes_key, 57);
}
void init_aes_47(ROP* rop_handle) {
	unsigned char aes_key[16] = { 84, 9, 139, 169, 70, 216, 146, 171, 59, 210, 193, 17, 1, 126, 181, 160, };
	unsigned char aes_iv[16] = { 123, 31, 76, 168, 60, 21, 168, 152, 97, 220, 20, 187, 192, 69, 250, 65, };
	rop_handle->init(aes_iv, aes_key, 2);
}
void init_aes_48(ROP* rop_handle) {
	unsigned char aes_key[16] = { 199, 30, 118, 101, 101, 138, 59, 221, 133, 38, 42, 201, 60, 157, 223, 169, };
	unsigned char aes_iv[16] = { 213, 1, 202, 93, 10, 64, 237, 111, 130, 14, 145, 202, 71, 39, 56, 105, };
	rop_handle->init(aes_iv, aes_key, 69);
}
void init_aes_49(ROP* rop_handle) {
	unsigned char aes_key[16] = { 104, 229, 23, 22, 91, 247, 178, 202, 67, 164, 189, 41, 54, 226, 237, 220, };
	unsigned char aes_iv[16] = { 249, 92, 176, 172, 92, 11, 156, 13, 180, 3, 215, 13, 94, 240, 163, 141, };
	rop_handle->init(aes_iv, aes_key, 1);
}
void init_aes_50(ROP* rop_handle) {
	unsigned char aes_key[16] = { 120, 126, 169, 59, 157, 233, 212, 51, 145, 18, 38, 254, 167, 42, 187, 185, };
	unsigned char aes_iv[16] = { 173, 76, 17, 48, 207, 117, 250, 73, 93, 244, 163, 248, 174, 72, 228, 106, };
	rop_handle->init(aes_iv, aes_key, 97);
}
void init_aes_51(ROP* rop_handle) {
	unsigned char aes_key[16] = { 101, 235, 206, 67, 210, 124, 50, 63, 216, 232, 9, 122, 179, 164, 89, 104, };
	unsigned char aes_iv[16] = { 108, 39, 137, 61, 176, 8, 41, 231, 249, 221, 232, 181, 155, 219, 253, 121, };
	rop_handle->init(aes_iv, aes_key, 38);
}
void init_aes_52(ROP* rop_handle) {
	unsigned char aes_key[16] = { 79, 245, 109, 71, 7, 184, 67, 146, 169, 97, 39, 51, 168, 131, 102, 95, };
	unsigned char aes_iv[16] = { 104, 29, 173, 66, 198, 208, 59, 100, 40, 129, 118, 40, 233, 121, 37, 131, };
	rop_handle->init(aes_iv, aes_key, 35);
}
void init_aes_53(ROP* rop_handle) {
	unsigned char aes_key[16] = { 53, 135, 84, 143, 64, 198, 161, 194, 154, 144, 137, 166, 161, 132, 228, 26, };
	unsigned char aes_iv[16] = { 161, 213, 114, 232, 251, 249, 55, 228, 2, 184, 243, 236, 37, 45, 254, 246, };
	rop_handle->init(aes_iv, aes_key, 98);
}
void init_aes_54(ROP* rop_handle) {
	unsigned char aes_key[16] = { 114, 82, 175, 3, 197, 179, 154, 183, 95, 167, 156, 11, 140, 44, 41, 159, };
	unsigned char aes_iv[16] = { 118, 111, 49, 5, 157, 247, 53, 216, 106, 112, 224, 22, 11, 229, 3, 210, };
	rop_handle->init(aes_iv, aes_key, 73);
}
void init_aes_55(ROP* rop_handle) {
	unsigned char aes_key[16] = { 84, 222, 243, 161, 164, 43, 1, 187, 203, 97, 153, 52, 165, 17, 29, 179, };
	unsigned char aes_iv[16] = { 124, 41, 237, 36, 97, 249, 45, 214, 80, 144, 163, 151, 123, 224, 207, 37, };
	rop_handle->init(aes_iv, aes_key, 32);
}
void init_aes_56(ROP* rop_handle) {
	unsigned char aes_key[16] = { 21, 98, 30, 50, 98, 74, 124, 177, 29, 138, 163, 45, 61, 27, 172, 1, };
	unsigned char aes_iv[16] = { 5, 107, 228, 219, 33, 246, 26, 99, 9, 237, 42, 140, 246, 23, 140, 53, };
	rop_handle->init(aes_iv, aes_key, 17);
}
void init_aes_57(ROP* rop_handle) {
	unsigned char aes_key[16] = { 252, 222, 106, 47, 93, 53, 51, 239, 200, 5, 59, 230, 146, 102, 89, 179, };
	unsigned char aes_iv[16] = { 26, 216, 209, 66, 229, 107, 126, 47, 187, 13, 159, 250, 148, 18, 54, 42, };
	rop_handle->init(aes_iv, aes_key, 49);
}
void init_aes_58(ROP* rop_handle) {
	unsigned char aes_key[16] = { 166, 11, 22, 248, 189, 230, 229, 29, 253, 51, 236, 172, 252, 49, 231, 103, };
	unsigned char aes_iv[16] = { 115, 177, 198, 209, 215, 237, 107, 96, 88, 120, 203, 148, 13, 205, 136, 178, };
	rop_handle->init(aes_iv, aes_key, 81);
}
void init_aes_59(ROP* rop_handle) {
	unsigned char aes_key[16] = { 204, 10, 48, 142, 196, 87, 159, 66, 118, 146, 104, 108, 52, 105, 78, 110, };
	unsigned char aes_iv[16] = { 16, 156, 211, 197, 62, 104, 221, 243, 145, 108, 172, 221, 14, 87, 198, 112, };
	rop_handle->init(aes_iv, aes_key, 5);
}
void init_aes_60(ROP* rop_handle) {
	unsigned char aes_key[16] = { 42, 7, 122, 54, 172, 123, 176, 249, 212, 191, 92, 119, 128, 195, 15, 246, };
	unsigned char aes_iv[16] = { 46, 58, 200, 73, 90, 2, 53, 159, 26, 31, 201, 196, 1, 172, 184, 223, };
	rop_handle->init(aes_iv, aes_key, 89);
}
void init_aes_61(ROP* rop_handle) {
	unsigned char aes_key[16] = { 253, 59, 116, 100, 64, 159, 102, 74, 190, 236, 173, 92, 123, 177, 203, 131, };
	unsigned char aes_iv[16] = { 199, 47, 147, 100, 8, 52, 226, 196, 239, 52, 99, 210, 182, 47, 246, 44, };
	rop_handle->init(aes_iv, aes_key, 48);
}
void init_aes_62(ROP* rop_handle) {
	unsigned char aes_key[16] = { 176, 172, 229, 53, 2, 238, 21, 241, 212, 64, 24, 13, 168, 142, 176, 146, };
	unsigned char aes_iv[16] = { 153, 225, 206, 247, 147, 62, 231, 227, 131, 13, 223, 61, 207, 83, 66, 36, };
	rop_handle->init(aes_iv, aes_key, 37);
}
void init_aes_63(ROP* rop_handle) {
	unsigned char aes_key[16] = { 169, 89, 191, 69, 228, 230, 232, 114, 122, 114, 158, 236, 168, 196, 15, 109, };
	unsigned char aes_iv[16] = { 204, 128, 49, 21, 86, 241, 75, 45, 225, 178, 46, 205, 160, 96, 146, 115, };
	rop_handle->init(aes_iv, aes_key, 61);
}
void init_aes_64(ROP* rop_handle) {
	unsigned char aes_key[16] = { 121, 157, 113, 125, 170, 31, 246, 42, 103, 180, 96, 163, 73, 29, 225, 13, };
	unsigned char aes_iv[16] = { 75, 96, 45, 92, 67, 19, 127, 79, 201, 213, 33, 193, 27, 21, 50, 42, };
	rop_handle->init(aes_iv, aes_key, 60);
}
void init_aes_65(ROP* rop_handle) {
	unsigned char aes_key[16] = { 235, 180, 157, 131, 223, 147, 39, 155, 25, 178, 55, 39, 200, 190, 148, 43, };
	unsigned char aes_iv[16] = { 56, 116, 99, 1, 244, 195, 205, 199, 234, 234, 23, 128, 122, 110, 39, 110, };
	rop_handle->init(aes_iv, aes_key, 90);
}
void init_aes_66(ROP* rop_handle) {
	unsigned char aes_key[16] = { 207, 17, 40, 164, 19, 232, 9, 4, 0, 238, 182, 78, 61, 129, 92, 235, };
	unsigned char aes_iv[16] = { 40, 246, 43, 221, 166, 162, 19, 254, 60, 123, 207, 166, 58, 237, 223, 198, };
	rop_handle->init(aes_iv, aes_key, 29);
}
void init_aes_67(ROP* rop_handle) {
	unsigned char aes_key[16] = { 71, 224, 135, 191, 84, 241, 66, 93, 12, 178, 205, 188, 31, 241, 243, 172, };
	unsigned char aes_iv[16] = { 137, 163, 100, 216, 112, 7, 36, 171, 227, 249, 8, 86, 4, 20, 217, 20, };
	rop_handle->init(aes_iv, aes_key, 41);
}
void init_aes_68(ROP* rop_handle) {
	unsigned char aes_key[16] = { 50, 14, 100, 166, 76, 10, 249, 69, 201, 11, 54, 54, 104, 191, 180, 121, };
	unsigned char aes_iv[16] = { 128, 3, 27, 136, 190, 232, 104, 240, 176, 192, 97, 167, 155, 126, 10, 10, };
	rop_handle->init(aes_iv, aes_key, 7);
}
void init_aes_69(ROP* rop_handle) {
	unsigned char aes_key[16] = { 188, 136, 167, 186, 227, 112, 61, 58, 64, 187, 37, 148, 102, 197, 229, 61, };
	unsigned char aes_iv[16] = { 198, 224, 161, 106, 238, 58, 97, 90, 5, 181, 63, 35, 103, 88, 19, 13, };
	rop_handle->init(aes_iv, aes_key, 16);
}
void init_aes_70(ROP* rop_handle) {
	unsigned char aes_key[16] = { 217, 144, 174, 3, 67, 97, 241, 246, 225, 131, 93, 210, 17, 246, 22, 203, };
	unsigned char aes_iv[16] = { 111, 94, 79, 133, 60, 229, 30, 36, 247, 191, 222, 41, 131, 195, 201, 63, };
	rop_handle->init(aes_iv, aes_key, 55);
}
void init_aes_71(ROP* rop_handle) {
	unsigned char aes_key[16] = { 36, 142, 161, 136, 81, 137, 211, 50, 151, 43, 124, 13, 187, 13, 119, 73, };
	unsigned char aes_iv[16] = { 249, 239, 180, 177, 90, 157, 95, 216, 8, 225, 130, 249, 70, 121, 177, 19, };
	rop_handle->init(aes_iv, aes_key, 8);
}
void init_aes_72(ROP* rop_handle) {
	unsigned char aes_key[16] = { 112, 67, 206, 175, 8, 73, 36, 19, 52, 171, 1, 54, 31, 167, 191, 161, };
	unsigned char aes_iv[16] = { 119, 154, 38, 5, 238, 148, 4, 192, 141, 5, 82, 107, 181, 183, 27, 94, };
	rop_handle->init(aes_iv, aes_key, 63);
}
void init_aes_73(ROP* rop_handle) {
	unsigned char aes_key[16] = { 188, 199, 161, 28, 10, 59, 229, 188, 138, 105, 55, 195, 13, 36, 160, 220, };
	unsigned char aes_iv[16] = { 149, 191, 10, 136, 242, 94, 205, 244, 62, 90, 245, 216, 207, 90, 142, 152, };
	rop_handle->init(aes_iv, aes_key, 22);
}
void init_aes_74(ROP* rop_handle) {
	unsigned char aes_key[16] = { 217, 39, 33, 4, 2, 137, 59, 178, 43, 13, 103, 86, 42, 20, 43, 22, };
	unsigned char aes_iv[16] = { 28, 180, 157, 254, 13, 225, 93, 10, 117, 255, 162, 36, 79, 142, 244, 29, };
	rop_handle->init(aes_iv, aes_key, 13);
}
void init_aes_75(ROP* rop_handle) {
	unsigned char aes_key[16] = { 163, 240, 20, 37, 151, 29, 31, 232, 175, 88, 250, 75, 232, 219, 205, 249, };
	unsigned char aes_iv[16] = { 196, 135, 208, 236, 202, 232, 14, 2, 46, 145, 210, 143, 35, 20, 127, 71, };
	rop_handle->init(aes_iv, aes_key, 92);
}
void init_aes_76(ROP* rop_handle) {
	unsigned char aes_key[16] = { 164, 168, 210, 117, 100, 154, 59, 49, 131, 218, 100, 55, 170, 63, 122, 118, };
	unsigned char aes_iv[16] = { 214, 111, 38, 228, 157, 90, 226, 207, 240, 178, 11, 28, 83, 84, 3, 98, };
	rop_handle->init(aes_iv, aes_key, 66);
}
void init_aes_77(ROP* rop_handle) {
	unsigned char aes_key[16] = { 230, 167, 160, 187, 133, 184, 243, 231, 211, 128, 224, 69, 14, 155, 0, 86, };
	unsigned char aes_iv[16] = { 37, 184, 118, 85, 13, 96, 143, 133, 43, 41, 75, 150, 19, 25, 147, 7, };
	rop_handle->init(aes_iv, aes_key, 65);
}
void init_aes_78(ROP* rop_handle) {
	unsigned char aes_key[16] = { 193, 30, 87, 203, 128, 85, 153, 118, 86, 178, 27, 36, 172, 49, 97, 148, };
	unsigned char aes_iv[16] = { 27, 151, 233, 18, 123, 155, 34, 79, 43, 95, 245, 84, 70, 210, 102, 225, };
	rop_handle->init(aes_iv, aes_key, 87);
}
void init_aes_79(ROP* rop_handle) {
	unsigned char aes_key[16] = { 101, 13, 234, 70, 227, 60, 198, 122, 33, 79, 59, 22, 199, 100, 198, 75, };
	unsigned char aes_iv[16] = { 84, 250, 74, 102, 86, 20, 78, 221, 147, 65, 19, 221, 87, 189, 26, 1, };
	rop_handle->init(aes_iv, aes_key, 50);
}
void init_aes_80(ROP* rop_handle) {
	unsigned char aes_key[16] = { 223, 152, 171, 47, 198, 35, 81, 162, 245, 237, 178, 179, 67, 74, 19, 122, };
	unsigned char aes_iv[16] = { 4, 158, 129, 77, 209, 68, 89, 250, 106, 146, 90, 208, 221, 92, 63, 255, };
	rop_handle->init(aes_iv, aes_key, 67);
}
void init_aes_81(ROP* rop_handle) {
	unsigned char aes_key[16] = { 192, 197, 71, 0, 52, 9, 178, 113, 94, 170, 140, 239, 207, 159, 85, 116, };
	unsigned char aes_iv[16] = { 134, 254, 160, 243, 254, 74, 99, 145, 29, 77, 165, 188, 65, 70, 191, 213, };
	rop_handle->init(aes_iv, aes_key, 51);
}
void init_aes_82(ROP* rop_handle) {
	unsigned char aes_key[16] = { 201, 18, 40, 249, 4, 254, 208, 90, 67, 139, 65, 83, 93, 121, 100, 42, };
	unsigned char aes_iv[16] = { 166, 235, 18, 62, 107, 89, 109, 108, 65, 9, 26, 192, 69, 163, 255, 7, };
	rop_handle->init(aes_iv, aes_key, 93);
}
void init_aes_83(ROP* rop_handle) {
	unsigned char aes_key[16] = { 10, 118, 93, 177, 173, 28, 58, 189, 196, 55, 227, 30, 64, 186, 113, 58, };
	unsigned char aes_iv[16] = { 50, 152, 89, 220, 164, 4, 66, 115, 157, 209, 147, 72, 222, 203, 202, 243, };
	rop_handle->init(aes_iv, aes_key, 20);
}
void init_aes_84(ROP* rop_handle) {
	unsigned char aes_key[16] = { 171, 120, 104, 65, 148, 72, 247, 75, 142, 238, 101, 45, 203, 122, 127, 114, };
	unsigned char aes_iv[16] = { 198, 168, 152, 246, 209, 210, 160, 103, 250, 238, 187, 86, 147, 66, 46, 174, };
	rop_handle->init(aes_iv, aes_key, 4);
}
void init_aes_85(ROP* rop_handle) {
	unsigned char aes_key[16] = { 143, 140, 126, 140, 94, 247, 144, 122, 154, 107, 49, 60, 26, 225, 252, 101, };
	unsigned char aes_iv[16] = { 159, 243, 134, 168, 14, 214, 176, 51, 59, 148, 43, 131, 249, 198, 43, 203, };
	rop_handle->init(aes_iv, aes_key, 96);
}
void init_aes_86(ROP* rop_handle) {
	unsigned char aes_key[16] = { 136, 16, 251, 135, 249, 52, 176, 9, 124, 83, 7, 93, 184, 198, 209, 177, };
	unsigned char aes_iv[16] = { 159, 72, 28, 103, 222, 196, 14, 232, 93, 47, 190, 143, 251, 112, 235, 243, };
	rop_handle->init(aes_iv, aes_key, 99);
}
void init_aes_87(ROP* rop_handle) {
	unsigned char aes_key[16] = { 30, 184, 224, 107, 71, 38, 36, 139, 136, 213, 71, 20, 226, 24, 213, 89, };
	unsigned char aes_iv[16] = { 234, 247, 165, 233, 128, 81, 169, 113, 81, 213, 88, 242, 185, 177, 162, 2, };
	rop_handle->init(aes_iv, aes_key, 83);
}
void init_aes_88(ROP* rop_handle) {
	unsigned char aes_key[16] = { 165, 103, 131, 208, 130, 94, 240, 2, 223, 4, 171, 51, 43, 127, 205, 214, };
	unsigned char aes_iv[16] = { 245, 173, 85, 171, 9, 109, 173, 217, 18, 243, 184, 176, 43, 195, 43, 109, };
	rop_handle->init(aes_iv, aes_key, 62);
}
void init_aes_89(ROP* rop_handle) {
	unsigned char aes_key[16] = { 34, 143, 113, 4, 14, 158, 43, 93, 28, 78, 34, 135, 23, 88, 185, 139, };
	unsigned char aes_iv[16] = { 224, 187, 39, 179, 168, 141, 111, 68, 254, 193, 173, 69, 60, 226, 153, 253, };
	rop_handle->init(aes_iv, aes_key, 88);
}
void init_aes_90(ROP* rop_handle) {
	unsigned char aes_key[16] = { 233, 98, 67, 82, 74, 100, 88, 130, 172, 140, 223, 164, 243, 73, 93, 202, };
	unsigned char aes_iv[16] = { 65, 226, 16, 155, 184, 10, 52, 212, 193, 203, 11, 140, 202, 38, 98, 6, };
	rop_handle->init(aes_iv, aes_key, 36);
}
void init_aes_91(ROP* rop_handle) {
	unsigned char aes_key[16] = { 99, 245, 7, 4, 16, 21, 63, 214, 76, 172, 238, 102, 210, 127, 138, 16, };
	unsigned char aes_iv[16] = { 220, 238, 151, 241, 14, 119, 101, 186, 39, 161, 114, 67, 247, 178, 142, 66, };
	rop_handle->init(aes_iv, aes_key, 84);
}
void init_aes_92(ROP* rop_handle) {
	unsigned char aes_key[16] = { 254, 170, 113, 208, 242, 202, 142, 15, 180, 58, 188, 255, 212, 120, 157, 73, };
	unsigned char aes_iv[16] = { 45, 48, 23, 64, 136, 133, 145, 174, 225, 176, 62, 227, 253, 44, 82, 253, };
	rop_handle->init(aes_iv, aes_key, 34);
}
void init_aes_93(ROP* rop_handle) {
	unsigned char aes_key[16] = { 91, 195, 216, 39, 236, 6, 8, 10, 41, 59, 13, 130, 80, 213, 160, 39, };
	unsigned char aes_iv[16] = { 129, 247, 45, 206, 107, 235, 120, 84, 109, 137, 121, 51, 219, 71, 251, 187, };
	rop_handle->init(aes_iv, aes_key, 23);
}
void init_aes_94(ROP* rop_handle) {
	unsigned char aes_key[16] = { 124, 141, 104, 159, 12, 80, 175, 54, 64, 209, 69, 253, 62, 139, 179, 178, };
	unsigned char aes_iv[16] = { 126, 120, 241, 57, 250, 173, 126, 30, 15, 186, 67, 142, 205, 50, 122, 90, };
	rop_handle->init(aes_iv, aes_key, 56);
}
void init_aes_95(ROP* rop_handle) {
	unsigned char aes_key[16] = { 239, 45, 169, 222, 253, 113, 196, 36, 145, 233, 2, 125, 208, 223, 89, 236, };
	unsigned char aes_iv[16] = { 210, 16, 229, 53, 219, 162, 246, 182, 45, 222, 196, 115, 58, 220, 161, 145, };
	rop_handle->init(aes_iv, aes_key, 39);
}
void init_aes_96(ROP* rop_handle) {
	unsigned char aes_key[16] = { 249, 179, 48, 129, 167, 73, 123, 153, 213, 123, 45, 187, 151, 100, 242, 193, };
	unsigned char aes_iv[16] = { 245, 217, 163, 64, 45, 221, 19, 11, 93, 177, 73, 23, 122, 51, 230, 110, };
	rop_handle->init(aes_iv, aes_key, 10);
}
void init_aes_97(ROP* rop_handle) {
	unsigned char aes_key[16] = { 176, 186, 169, 16, 183, 163, 234, 74, 175, 156, 43, 15, 230, 249, 158, 183, };
	unsigned char aes_iv[16] = { 178, 118, 127, 8, 120, 127, 66, 49, 194, 75, 3, 45, 61, 147, 220, 67, };
	rop_handle->init(aes_iv, aes_key, 72);
}
void init_aes_98(ROP* rop_handle) {
	unsigned char aes_key[16] = { 98, 200, 159, 214, 247, 124, 34, 110, 152, 170, 242, 103, 107, 244, 59, 211, };
	unsigned char aes_iv[16] = { 170, 218, 13, 23, 78, 116, 38, 84, 52, 134, 168, 181, 66, 119, 171, 177, };
	rop_handle->init(aes_iv, aes_key, 0);
}
void init_aes_99(ROP* rop_handle) {
	unsigned char aes_key[16] = { 100, 184, 81, 179, 190, 191, 33, 242, 223, 153, 61, 50, 58, 249, 174, 143, };
	unsigned char aes_iv[16] = { 64, 151, 205, 165, 211, 250, 0, 76, 31, 175, 222, 88, 134, 203, 22, 201, };
	rop_handle->init(aes_iv, aes_key, 11);
}
//[[109, 119, 57, 143, 32, 234, 139, 146, 228, 246, 5, 252, 109, 34, 41, 135], [156, 193, 114, 138, 249, 156, 52, 132, 161, 8, 115, 189, 179, 238, 114, 60], [23, 215, 123, 125, 192, 161, 105, 248, 223, 67, 219, 53, 6, 184, 238, 240], [195, 111, 141, 24, 234, 128, 170, 182, 216, 16, 41, 0, 174, 228, 215, 148], [125, 176, 74, 10, 199, 120, 103, 110, 206, 178, 92, 145, 86, 105, 241, 220], [188, 219, 204, 82, 61, 177, 124, 2, 113, 18, 115, 75, 245, 223, 186, 4], [104, 217, 250, 26, 229, 254, 61, 198, 63, 213, 30, 133, 58, 183, 127, 207], [62, 199, 154, 120, 92, 102, 229, 66, 74, 19, 197, 246, 224, 88, 151, 1], [232, 165, 186, 62, 206, 99, 135, 179, 11, 149, 68, 155, 209, 220, 108, 214], [238, 92, 161, 84, 36, 37, 154, 58, 104, 181, 250, 208, 95, 19, 67, 221], [115, 26, 198, 75, 32, 179, 80, 181, 6, 172, 183, 124, 107, 212, 99, 2], [138, 177, 24, 135, 227, 253, 232, 112, 28, 139, 79, 69, 4, 185, 106, 213], [202, 226, 253, 167, 24, 227, 226, 126, 216, 119, 125, 42, 213, 122, 85, 253], [198, 133, 253, 178, 136, 76, 21, 130, 2, 174, 106, 122, 245, 227, 171, 219], [164, 59, 221, 204, 176, 147, 111, 105, 147, 40, 197, 71, 165, 125, 231, 5], [155, 130, 119, 235, 18, 108, 70, 40, 15, 228, 249, 145, 3, 215, 84, 32], [148, 7, 9, 168, 61, 41, 221, 210, 137, 100, 229, 237, 141, 253, 66, 109], [227, 107, 66, 21, 208, 70, 18, 130, 162, 207, 47, 56, 209, 31, 191, 113], [124, 10, 47, 244, 120, 71, 41, 230, 139, 185, 60, 133, 18, 157, 115, 235], [180, 86, 25, 195, 105, 96, 167, 127, 197, 123, 48, 26, 150, 139, 16, 119], [21, 240, 89, 126, 245, 83, 182, 107, 101, 195, 157, 231, 110, 29, 115, 176], [106, 245, 150, 246, 80, 209, 202, 241, 43, 128, 144, 222, 100, 146, 255, 101], [226, 106, 66, 102, 30, 197, 103, 191, 9, 138, 110, 134, 170, 92, 20, 149], [72, 196, 150, 174, 45, 196, 151, 4, 130, 76, 14, 124, 224, 209, 246, 203], [249, 31, 224, 88, 222, 87, 66, 227, 77, 4, 1, 7, 224, 254, 102, 156], [132, 216, 31, 188, 119, 60, 218, 229, 134, 229, 225, 11, 97, 115, 9, 13], [66, 91, 6, 98, 66, 135, 169, 110, 136, 155, 154, 47, 232, 46, 4, 115], [137, 11, 57, 224, 146, 169, 147, 144, 137, 1, 242, 240, 128, 144, 116, 196], [51, 168, 3, 164, 78, 107, 107, 200, 215, 242, 106, 193, 130, 73, 148, 33], [230, 180, 220, 149, 232, 2, 96, 64, 129, 186, 82, 250, 15, 52, 130, 24], [197, 109, 10, 250, 141, 167, 179, 192, 184, 151, 118, 78, 155, 78, 195, 11], [231, 234, 205, 73, 28, 133, 238, 233, 234, 245, 29, 162, 120, 132, 214, 139], [76, 128, 19, 190, 27, 80, 64, 94, 195, 198, 36, 95, 219, 102, 156, 130], [41, 225, 14, 144, 100, 113, 43, 184, 146, 173, 27, 187, 9, 107, 7, 44], [63, 132, 140, 157, 117, 62, 228, 252, 107, 43, 14, 75, 203, 225, 60, 191], [4, 15, 82, 156, 39, 237, 132, 48, 48, 139, 26, 41, 93, 170, 223, 170], [244, 182, 80, 105, 86, 21, 150, 37, 11, 82, 220, 95, 78, 151, 216, 181], [192, 245, 85, 246, 29, 21, 77, 117, 231, 144, 164, 148, 0, 147, 150, 91], [49, 5, 187, 193, 244, 0, 159, 160, 23, 1, 59, 121, 246, 227, 132, 77], [225, 253, 231, 38, 240, 234, 61, 1, 108, 241, 145, 125, 48, 223, 50, 8], [205, 7, 204, 221, 82, 93, 40, 238, 37, 179, 216, 127, 188, 209, 180, 236], [249, 137, 60, 213, 12, 203, 151, 241, 187, 107, 3, 166, 159, 98, 132, 251], [207, 69, 75, 224, 172, 245, 233, 183, 30, 202, 55, 99, 178, 239, 14, 253], [31, 230, 101, 73, 234, 126, 99, 13, 126, 238, 169, 45, 71, 76, 62, 178], [178, 159, 147, 175, 114, 75, 215, 246, 204, 56, 83, 54, 8, 138, 143, 40], [123, 4, 111, 55, 68, 12, 150, 129, 65, 201, 112, 221, 44, 147, 166, 251], [48, 143, 152, 52, 83, 137, 78, 32, 254, 192, 115, 195, 55, 106, 125, 222], [157, 34, 164, 141, 103, 11, 207, 164, 89, 6, 56, 229, 231, 60, 26, 146], [18, 173, 192, 238, 215, 69, 8, 22, 211, 161, 133, 15, 35, 67, 61, 93], [236, 24, 2, 102, 218, 135, 90, 242, 180, 79, 225, 0, 64, 181, 37, 52], [192, 17, 205, 127, 250, 187, 44, 186, 181, 36, 181, 48, 221, 81, 139, 90], [13, 224, 173, 54, 137, 168, 105, 129, 72, 93, 155, 146, 101, 73, 248, 100], [135, 91, 124, 44, 196, 89, 37, 30, 177, 186, 50, 185, 139, 233, 249, 86], [207, 113, 218, 115, 45, 141, 205, 133, 165, 107, 58, 109, 99, 52, 66, 39], [11, 143, 111, 165, 91, 247, 94, 6, 194, 196, 65, 14, 227, 149, 202, 37], [255, 20, 209, 117, 246, 188, 55, 124, 102, 244, 239, 55, 107, 70, 174, 167], [88, 201, 150, 215, 241, 133, 252, 155, 2, 249, 179, 125, 83, 42, 118, 178], [213, 71, 77, 85, 214, 180, 131, 101, 102, 17, 134, 63, 193, 235, 123, 53], [134, 61, 229, 41, 45, 104, 29, 204, 114, 166, 214, 136, 253, 99, 190, 110], [207, 214, 59, 85, 176, 94, 57, 229, 206, 48, 125, 119, 29, 186, 59, 55], [100, 131, 10, 189, 76, 247, 210, 214, 7, 202, 68, 101, 140, 1, 211, 92], [34, 46, 48, 39, 169, 174, 211, 26, 247, 174, 97, 52, 51, 11, 52, 30], [188, 13, 135, 155, 25, 231, 158, 17, 131, 238, 148, 177, 50, 62, 243, 131], [85, 48, 170, 252, 167, 209, 231, 215, 180, 93, 197, 174, 115, 119, 229, 202], [168, 223, 11, 100, 119, 126, 114, 189, 210, 80, 252, 9, 113, 66, 178, 59], [180, 72, 101, 138, 212, 128, 136, 239, 195, 188, 206, 30, 38, 82, 174, 47], [28, 109, 151, 46, 242, 247, 223, 249, 15, 12, 181, 33, 190, 76, 69, 3], [248, 120, 146, 127, 190, 148, 107, 113, 233, 210, 44, 42, 93, 87, 208, 188], [47, 52, 186, 53, 184, 85, 197, 96, 100, 199, 41, 134, 28, 225, 225, 11], [177, 138, 108, 216, 88, 171, 143, 88, 238, 0, 172, 56, 181, 233, 137, 8], [17, 176, 53, 0, 85, 199, 157, 199, 128, 154, 77, 57, 48, 124, 17, 115], [70, 28, 137, 255, 228, 56, 136, 86, 190, 214, 135, 220, 72, 164, 250, 220], [136, 178, 243, 14, 91, 20, 38, 197, 18, 205, 136, 249, 66, 14, 29, 106], [187, 128, 2, 87, 219, 16, 33, 161, 127, 169, 9, 200, 84, 223, 21, 191], [162, 196, 179, 75, 86, 227, 242, 213, 44, 112, 130, 115, 245, 223, 242, 201], [98, 51, 57, 143, 158, 240, 88, 163, 97, 98, 132, 110, 209, 56, 100, 139], [209, 90, 208, 99, 182, 104, 26, 12, 10, 194, 184, 187, 139, 41, 236, 238], [92, 200, 156, 68, 86, 148, 153, 75, 4, 117, 158, 143, 49, 46, 120, 167], [108, 162, 221, 223, 49, 249, 144, 108, 30, 236, 20, 14, 11, 38, 97, 165], [225, 171, 104, 178, 155, 58, 56, 89, 238, 13, 8, 124, 234, 178, 134, 100], [134, 225, 75, 157, 143, 8, 61, 18, 226, 137, 229, 155, 143, 174, 18, 94], [90, 122, 94, 155, 56, 106, 11, 253, 146, 233, 119, 95, 162, 117, 207, 182], [47, 134, 155, 246, 3, 121, 157, 240, 74, 211, 229, 2, 159, 146, 130, 14], [234, 200, 222, 94, 164, 34, 187, 43, 57, 63, 122, 39, 45, 182, 235, 224], [138, 109, 92, 248, 202, 160, 159, 79, 75, 205, 179, 255, 50, 168, 178, 67], [209, 186, 51, 143, 54, 93, 71, 193, 113, 254, 78, 38, 233, 36, 136, 41], [254, 116, 4, 34, 109, 212, 88, 167, 50, 182, 103, 154, 161, 149, 2, 163], [134, 4, 62, 162, 168, 18, 202, 175, 61, 39, 117, 129, 137, 187, 181, 152], [56, 103, 255, 117, 162, 16, 95, 178, 137, 12, 240, 66, 110, 81, 19, 212], [18, 124, 184, 87, 27, 73, 234, 97, 171, 232, 10, 125, 176, 72, 136, 142], [69, 30, 217, 183, 210, 127, 5, 137, 128, 173, 158, 182, 170, 197, 50, 202], [26, 191, 242, 150, 191, 57, 135, 225, 36, 34, 253, 176, 148, 128, 228, 239], [176, 50, 209, 157, 181, 67, 13, 112, 245, 206, 188, 150, 143, 103, 240, 57], [173, 221, 123, 15, 232, 180, 217, 145, 213, 198, 92, 78, 19, 213, 42, 38], [84, 9, 139, 169, 70, 216, 146, 171, 59, 210, 193, 17, 1, 126, 181, 160], [123, 31, 76, 168, 60, 21, 168, 152, 97, 220, 20, 187, 192, 69, 250, 65], [199, 30, 118, 101, 101, 138, 59, 221, 133, 38, 42, 201, 60, 157, 223, 169], [213, 1, 202, 93, 10, 64, 237, 111, 130, 14, 145, 202, 71, 39, 56, 105], [104, 229, 23, 22, 91, 247, 178, 202, 67, 164, 189, 41, 54, 226, 237, 220], [249, 92, 176, 172, 92, 11, 156, 13, 180, 3, 215, 13, 94, 240, 163, 141], [120, 126, 169, 59, 157, 233, 212, 51, 145, 18, 38, 254, 167, 42, 187, 185], [173, 76, 17, 48, 207, 117, 250, 73, 93, 244, 163, 248, 174, 72, 228, 106], [101, 235, 206, 67, 210, 124, 50, 63, 216, 232, 9, 122, 179, 164, 89, 104], [108, 39, 137, 61, 176, 8, 41, 231, 249, 221, 232, 181, 155, 219, 253, 121], [79, 245, 109, 71, 7, 184, 67, 146, 169, 97, 39, 51, 168, 131, 102, 95], [104, 29, 173, 66, 198, 208, 59, 100, 40, 129, 118, 40, 233, 121, 37, 131], [53, 135, 84, 143, 64, 198, 161, 194, 154, 144, 137, 166, 161, 132, 228, 26], [161, 213, 114, 232, 251, 249, 55, 228, 2, 184, 243, 236, 37, 45, 254, 246], [114, 82, 175, 3, 197, 179, 154, 183, 95, 167, 156, 11, 140, 44, 41, 159], [118, 111, 49, 5, 157, 247, 53, 216, 106, 112, 224, 22, 11, 229, 3, 210], [84, 222, 243, 161, 164, 43, 1, 187, 203, 97, 153, 52, 165, 17, 29, 179], [124, 41, 237, 36, 97, 249, 45, 214, 80, 144, 163, 151, 123, 224, 207, 37], [21, 98, 30, 50, 98, 74, 124, 177, 29, 138, 163, 45, 61, 27, 172, 1], [5, 107, 228, 219, 33, 246, 26, 99, 9, 237, 42, 140, 246, 23, 140, 53], [252, 222, 106, 47, 93, 53, 51, 239, 200, 5, 59, 230, 146, 102, 89, 179], [26, 216, 209, 66, 229, 107, 126, 47, 187, 13, 159, 250, 148, 18, 54, 42], [166, 11, 22, 248, 189, 230, 229, 29, 253, 51, 236, 172, 252, 49, 231, 103], [115, 177, 198, 209, 215, 237, 107, 96, 88, 120, 203, 148, 13, 205, 136, 178], [204, 10, 48, 142, 196, 87, 159, 66, 118, 146, 104, 108, 52, 105, 78, 110], [16, 156, 211, 197, 62, 104, 221, 243, 145, 108, 172, 221, 14, 87, 198, 112], [42, 7, 122, 54, 172, 123, 176, 249, 212, 191, 92, 119, 128, 195, 15, 246], [46, 58, 200, 73, 90, 2, 53, 159, 26, 31, 201, 196, 1, 172, 184, 223], [253, 59, 116, 100, 64, 159, 102, 74, 190, 236, 173, 92, 123, 177, 203, 131], [199, 47, 147, 100, 8, 52, 226, 196, 239, 52, 99, 210, 182, 47, 246, 44], [176, 172, 229, 53, 2, 238, 21, 241, 212, 64, 24, 13, 168, 142, 176, 146], [153, 225, 206, 247, 147, 62, 231, 227, 131, 13, 223, 61, 207, 83, 66, 36], [169, 89, 191, 69, 228, 230, 232, 114, 122, 114, 158, 236, 168, 196, 15, 109], [204, 128, 49, 21, 86, 241, 75, 45, 225, 178, 46, 205, 160, 96, 146, 115], [121, 157, 113, 125, 170, 31, 246, 42, 103, 180, 96, 163, 73, 29, 225, 13], [75, 96, 45, 92, 67, 19, 127, 79, 201, 213, 33, 193, 27, 21, 50, 42], [235, 180, 157, 131, 223, 147, 39, 155, 25, 178, 55, 39, 200, 190, 148, 43], [56, 116, 99, 1, 244, 195, 205, 199, 234, 234, 23, 128, 122, 110, 39, 110], [207, 17, 40, 164, 19, 232, 9, 4, 0, 238, 182, 78, 61, 129, 92, 235], [40, 246, 43, 221, 166, 162, 19, 254, 60, 123, 207, 166, 58, 237, 223, 198], [71, 224, 135, 191, 84, 241, 66, 93, 12, 178, 205, 188, 31, 241, 243, 172], [137, 163, 100, 216, 112, 7, 36, 171, 227, 249, 8, 86, 4, 20, 217, 20], [50, 14, 100, 166, 76, 10, 249, 69, 201, 11, 54, 54, 104, 191, 180, 121], [128, 3, 27, 136, 190, 232, 104, 240, 176, 192, 97, 167, 155, 126, 10, 10], [188, 136, 167, 186, 227, 112, 61, 58, 64, 187, 37, 148, 102, 197, 229, 61], [198, 224, 161, 106, 238, 58, 97, 90, 5, 181, 63, 35, 103, 88, 19, 13], [217, 144, 174, 3, 67, 97, 241, 246, 225, 131, 93, 210, 17, 246, 22, 203], [111, 94, 79, 133, 60, 229, 30, 36, 247, 191, 222, 41, 131, 195, 201, 63], [36, 142, 161, 136, 81, 137, 211, 50, 151, 43, 124, 13, 187, 13, 119, 73], [249, 239, 180, 177, 90, 157, 95, 216, 8, 225, 130, 249, 70, 121, 177, 19], [112, 67, 206, 175, 8, 73, 36, 19, 52, 171, 1, 54, 31, 167, 191, 161], [119, 154, 38, 5, 238, 148, 4, 192, 141, 5, 82, 107, 181, 183, 27, 94], [188, 199, 161, 28, 10, 59, 229, 188, 138, 105, 55, 195, 13, 36, 160, 220], [149, 191, 10, 136, 242, 94, 205, 244, 62, 90, 245, 216, 207, 90, 142, 152], [217, 39, 33, 4, 2, 137, 59, 178, 43, 13, 103, 86, 42, 20, 43, 22], [28, 180, 157, 254, 13, 225, 93, 10, 117, 255, 162, 36, 79, 142, 244, 29], [163, 240, 20, 37, 151, 29, 31, 232, 175, 88, 250, 75, 232, 219, 205, 249], [196, 135, 208, 236, 202, 232, 14, 2, 46, 145, 210, 143, 35, 20, 127, 71], [164, 168, 210, 117, 100, 154, 59, 49, 131, 218, 100, 55, 170, 63, 122, 118], [214, 111, 38, 228, 157, 90, 226, 207, 240, 178, 11, 28, 83, 84, 3, 98], [230, 167, 160, 187, 133, 184, 243, 231, 211, 128, 224, 69, 14, 155, 0, 86], [37, 184, 118, 85, 13, 96, 143, 133, 43, 41, 75, 150, 19, 25, 147, 7], [193, 30, 87, 203, 128, 85, 153, 118, 86, 178, 27, 36, 172, 49, 97, 148], [27, 151, 233, 18, 123, 155, 34, 79, 43, 95, 245, 84, 70, 210, 102, 225], [101, 13, 234, 70, 227, 60, 198, 122, 33, 79, 59, 22, 199, 100, 198, 75], [84, 250, 74, 102, 86, 20, 78, 221, 147, 65, 19, 221, 87, 189, 26, 1], [223, 152, 171, 47, 198, 35, 81, 162, 245, 237, 178, 179, 67, 74, 19, 122], [4, 158, 129, 77, 209, 68, 89, 250, 106, 146, 90, 208, 221, 92, 63, 255], [192, 197, 71, 0, 52, 9, 178, 113, 94, 170, 140, 239, 207, 159, 85, 116], [134, 254, 160, 243, 254, 74, 99, 145, 29, 77, 165, 188, 65, 70, 191, 213], [201, 18, 40, 249, 4, 254, 208, 90, 67, 139, 65, 83, 93, 121, 100, 42], [166, 235, 18, 62, 107, 89, 109, 108, 65, 9, 26, 192, 69, 163, 255, 7], [10, 118, 93, 177, 173, 28, 58, 189, 196, 55, 227, 30, 64, 186, 113, 58], [50, 152, 89, 220, 164, 4, 66, 115, 157, 209, 147, 72, 222, 203, 202, 243], [171, 120, 104, 65, 148, 72, 247, 75, 142, 238, 101, 45, 203, 122, 127, 114], [198, 168, 152, 246, 209, 210, 160, 103, 250, 238, 187, 86, 147, 66, 46, 174], [143, 140, 126, 140, 94, 247, 144, 122, 154, 107, 49, 60, 26, 225, 252, 101], [159, 243, 134, 168, 14, 214, 176, 51, 59, 148, 43, 131, 249, 198, 43, 203], [136, 16, 251, 135, 249, 52, 176, 9, 124, 83, 7, 93, 184, 198, 209, 177], [159, 72, 28, 103, 222, 196, 14, 232, 93, 47, 190, 143, 251, 112, 235, 243], [30, 184, 224, 107, 71, 38, 36, 139, 136, 213, 71, 20, 226, 24, 213, 89], [234, 247, 165, 233, 128, 81, 169, 113, 81, 213, 88, 242, 185, 177, 162, 2], [165, 103, 131, 208, 130, 94, 240, 2, 223, 4, 171, 51, 43, 127, 205, 214], [245, 173, 85, 171, 9, 109, 173, 217, 18, 243, 184, 176, 43, 195, 43, 109], [34, 143, 113, 4, 14, 158, 43, 93, 28, 78, 34, 135, 23, 88, 185, 139], [224, 187, 39, 179, 168, 141, 111, 68, 254, 193, 173, 69, 60, 226, 153, 253], [233, 98, 67, 82, 74, 100, 88, 130, 172, 140, 223, 164, 243, 73, 93, 202], [65, 226, 16, 155, 184, 10, 52, 212, 193, 203, 11, 140, 202, 38, 98, 6], [99, 245, 7, 4, 16, 21, 63, 214, 76, 172, 238, 102, 210, 127, 138, 16], [220, 238, 151, 241, 14, 119, 101, 186, 39, 161, 114, 67, 247, 178, 142, 66], [254, 170, 113, 208, 242, 202, 142, 15, 180, 58, 188, 255, 212, 120, 157, 73], [45, 48, 23, 64, 136, 133, 145, 174, 225, 176, 62, 227, 253, 44, 82, 253], [91, 195, 216, 39, 236, 6, 8, 10, 41, 59, 13, 130, 80, 213, 160, 39], [129, 247, 45, 206, 107, 235, 120, 84, 109, 137, 121, 51, 219, 71, 251, 187], [124, 141, 104, 159, 12, 80, 175, 54, 64, 209, 69, 253, 62, 139, 179, 178], [126, 120, 241, 57, 250, 173, 126, 30, 15, 186, 67, 142, 205, 50, 122, 90], [239, 45, 169, 222, 253, 113, 196, 36, 145, 233, 2, 125, 208, 223, 89, 236], [210, 16, 229, 53, 219, 162, 246, 182, 45, 222, 196, 115, 58, 220, 161, 145], [249, 179, 48, 129, 167, 73, 123, 153, 213, 123, 45, 187, 151, 100, 242, 193], [245, 217, 163, 64, 45, 221, 19, 11, 93, 177, 73, 23, 122, 51, 230, 110], [176, 186, 169, 16, 183, 163, 234, 74, 175, 156, 43, 15, 230, 249, 158, 183], [178, 118, 127, 8, 120, 127, 66, 49, 194, 75, 3, 45, 61, 147, 220, 67], [98, 200, 159, 214, 247, 124, 34, 110, 152, 170, 242, 103, 107, 244, 59, 211], [170, 218, 13, 23, 78, 116, 38, 84, 52, 134, 168, 181, 66, 119, 171, 177], [100, 184, 81, 179, 190, 191, 33, 242, 223, 153, 61, 50, 58, 249, 174, 143], [64, 151, 205, 165, 211, 250, 0, 76, 31, 175, 222, 88, 134, 203, 22, 201]]


void encrypt_send0(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xcc, 0x99, 0xe, 0xf8, 0xf6, 0x49, 0xc1, 0xe7, 0x79, 0x13, 0x4c, 0x10, 0xf6, 0xb4, 0x9a, 0x52, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send1(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x69, 0xdd, 0x7d, 0xf1, 0xd2, 0x7c, 0x7d, 0x6e, 0xc5, 0xf3, 0x2d, 0x82, 0x34, 0x3f, 0xe0, 0x1d, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send2(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x14, 0xa4, 0xdc, 0x33, 0x8f, 0x0, 0x73, 0x1c, 0xe0, 0x8b, 0x74, 0x4c, 0x71, 0x47, 0x50, 0xa4, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send3(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x14, 0x13, 0xb4, 0x70, 0x4d, 0xd3, 0xe0, 0x19, 0x15, 0x38, 0x76, 0x89, 0x73, 0x15, 0x87, 0xcd, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send4(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xe, 0x33, 0x91, 0x3, 0x57, 0x95, 0xb6, 0xd0, 0xe6, 0xf2, 0x93, 0x63, 0x69, 0x38, 0xfe, 0x27, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send5(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x7e, 0xba, 0xca, 0xe3, 0x78, 0x40, 0x21, 0xe0, 0x2a, 0x13, 0x26, 0x83, 0xe4, 0x57, 0x48, 0x77, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send6(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x74, 0x28, 0xb9, 0xb2, 0x85, 0x20, 0xd6, 0x47, 0x91, 0xda, 0x54, 0xb7, 0xc0, 0x59, 0xb5, 0xec, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send7(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x48, 0xca, 0x2d, 0x4c, 0x2e, 0xd5, 0xf, 0xa3, 0xf6, 0x72, 0x69, 0x50, 0x1a, 0x32, 0xe1, 0x24, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send8(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x79, 0x4b, 0x50, 0xa7, 0x5b, 0xf5, 0xe0, 0x8c, 0x83, 0xdf, 0xd, 0xad, 0x5e, 0x92, 0x10, 0xe1, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send9(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x9f, 0x1e, 0xa0, 0xaf, 0xd5, 0xca, 0x49, 0x9b, 0x95, 0x26, 0x1e, 0x1c, 0xa5, 0xaf, 0x65, 0xc9, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send10(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x68, 0xb9, 0xec, 0x94, 0xef, 0x8a, 0xe0, 0xb0, 0x53, 0x39, 0x8c, 0x45, 0x91, 0xca, 0xba, 0xe2, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send11(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x39, 0x8a, 0x78, 0xdd, 0x4f, 0x2b, 0xdd, 0xd9, 0x77, 0x42, 0x3b, 0x65, 0x98, 0x68, 0x98, 0x6, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send12(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xeb, 0xe5, 0x40, 0xdf, 0xf7, 0xd8, 0x9c, 0xae, 0x4e, 0x13, 0x13, 0xe6, 0x99, 0x33, 0x7e, 0x37, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send13(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x59, 0xca, 0x45, 0x36, 0x43, 0x87, 0x95, 0xc, 0x1, 0x93, 0x62, 0xbb, 0xe8, 0xf2, 0xe9, 0xba, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send14(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x33, 0x5, 0x9d, 0x19, 0xe0, 0x6f, 0xe0, 0x5, 0x65, 0x99, 0x7b, 0x7d, 0x28, 0x2, 0xbb, 0xc5, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send15(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xe5, 0xef, 0x56, 0xc7, 0x96, 0x1e, 0x94, 0x51, 0x35, 0xbe, 0x9c, 0xfa, 0x94, 0xbb, 0x6c, 0x9f, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send16(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xde, 0x82, 0xd6, 0x67, 0xd1, 0x8, 0x92, 0x43, 0x63, 0x2a, 0xb8, 0x60, 0xcd, 0x17, 0x2, 0x14, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send17(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xd4, 0x28, 0xab, 0x36, 0x57, 0xb8, 0x2, 0xe7, 0x39, 0x2f, 0x87, 0xa2, 0xe9, 0xb7, 0x5d, 0x2d, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send18(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xc, 0xf2, 0x21, 0x3f, 0x36, 0x87, 0xb7, 0x2f, 0x6f, 0xb2, 0xc3, 0x78, 0x9d, 0x19, 0x26, 0x68, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send19(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xf9, 0x39, 0x28, 0x93, 0xa3, 0x6a, 0x17, 0xfc, 0x2c, 0xc4, 0x6f, 0xda, 0xdc, 0xe5, 0xe0, 0x4b, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send20(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xc4, 0x3c, 0x9b, 0x29, 0xb1, 0x37, 0x83, 0xd6, 0xed, 0xf2, 0xe3, 0x1e, 0xe3, 0x4c, 0x18, 0x90, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send21(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x35, 0x56, 0xd, 0x59, 0xd6, 0x34, 0xd1, 0xe6, 0xdd, 0xcb, 0xc0, 0xe7, 0x83, 0x15, 0x3b, 0x1c, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send22(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xeb, 0x8a, 0xf5, 0x69, 0x94, 0xee, 0x9a, 0x10, 0x8d, 0x17, 0x24, 0x8a, 0x90, 0x3d, 0x65, 0x1d, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send23(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x34, 0x30, 0xa6, 0xcf, 0x10, 0xbb, 0xf5, 0x49, 0x9a, 0x81, 0x1c, 0x8d, 0x9d, 0xb7, 0x4e, 0x25, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send24(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x12, 0x18, 0xc, 0xb0, 0x45, 0xdf, 0xa7, 0x21, 0xa7, 0x6d, 0x5d, 0x5b, 0x49, 0x26, 0x8c, 0x6b, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send25(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x77, 0x5d, 0xc, 0x27, 0xc, 0xaa, 0xe3, 0x8, 0x1a, 0xd3, 0x5e, 0xb1, 0x67, 0x41, 0x88, 0x9e, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send26(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x60, 0xd1, 0x97, 0x4d, 0xd6, 0xa4, 0xc6, 0xb9, 0x8d, 0x11, 0x6d, 0x59, 0x2b, 0xcb, 0x33, 0x6f, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send27(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x77, 0x8c, 0x9e, 0xa3, 0xc9, 0xd6, 0xd, 0x64, 0xdf, 0xd5, 0x40, 0xdf, 0x27, 0x70, 0xe2, 0xca, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send28(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xfe, 0x48, 0xe9, 0xc3, 0x7c, 0x3b, 0x3e, 0x59, 0x53, 0x13, 0x33, 0x4c, 0x3c, 0xd8, 0x31, 0x6b, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send29(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x79, 0xa0, 0xf1, 0xb6, 0xae, 0x72, 0x72, 0xa8, 0xc8, 0x5a, 0xdd, 0x1b, 0x8b, 0xe5, 0x1d, 0x40, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send30(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x6b, 0x13, 0x17, 0x19, 0x20, 0xeb, 0xf3, 0xf0, 0xea, 0xe3, 0x94, 0xdc, 0xbd, 0xda, 0xa2, 0x1e, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send31(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x30, 0x1a, 0xcd, 0xd, 0xeb, 0xdc, 0x2, 0xf, 0xe8, 0xf0, 0xcb, 0x18, 0x78, 0xc1, 0x4f, 0xe0, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send32(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x2c, 0xcf, 0xe2, 0x1a, 0xd3, 0xdb, 0x60, 0x11, 0x1e, 0x0, 0x21, 0xf3, 0xad, 0x1, 0x98, 0x19, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send33(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x17, 0x6b, 0xbb, 0x65, 0x33, 0xe9, 0xfa, 0x47, 0x34, 0x35, 0x3c, 0xd, 0xb6, 0x73, 0xbe, 0x9, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send34(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xa7, 0xf6, 0xca, 0x59, 0xa9, 0xb1, 0x78, 0xad, 0x30, 0x3c, 0x12, 0xd7, 0xa3, 0x6c, 0xc7, 0xdb, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send35(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x70, 0xea, 0xed, 0xf4, 0xb7, 0x1, 0x55, 0x6b, 0x1c, 0xc9, 0x27, 0x17, 0x59, 0x3e, 0x69, 0x6d, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send36(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xac, 0x93, 0xe4, 0x50, 0x65, 0xf8, 0x9f, 0xc, 0x23, 0x80, 0x74, 0x23, 0xd5, 0x55, 0xb1, 0xc2, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send37(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x2d, 0xc2, 0xe7, 0xd, 0x24, 0x9b, 0xc7, 0x89, 0x59, 0xc, 0x5e, 0xc7, 0x20, 0x47, 0xc, 0xd9, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send38(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x31, 0x21, 0xd7, 0xb8, 0x37, 0xb4, 0x96, 0xe0, 0xcb, 0x35, 0xc6, 0x4f, 0x52, 0x48, 0x8, 0xab, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send39(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x9d, 0xe1, 0x61, 0xb7, 0x61, 0x80, 0x77, 0x76, 0x78, 0x13, 0xc2, 0x1e, 0x30, 0xbf, 0xb, 0x13, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send40(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x9a, 0xec, 0x17, 0x31, 0xc9, 0xf1, 0x8e, 0xab, 0x22, 0x5, 0x27, 0xe4, 0x68, 0x8d, 0x7e, 0x8d, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send41(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xa6, 0x2b, 0xd8, 0x81, 0xf2, 0x7d, 0x55, 0x2a, 0x85, 0xd5, 0xb1, 0x51, 0x1e, 0x2d, 0x4a, 0x64, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send42(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x58, 0xbc, 0xbe, 0xfd, 0xf4, 0x96, 0x0, 0x19, 0xcb, 0xe6, 0xe3, 0xd0, 0x13, 0xdb, 0x93, 0x12, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send43(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xfb, 0xce, 0x4b, 0x67, 0x3f, 0x2, 0x40, 0x2e, 0xee, 0x76, 0x9c, 0xe2, 0x3a, 0xae, 0x8f, 0xe9, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send44(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x93, 0x83, 0x59, 0x93, 0xbf, 0xa9, 0x3, 0xc7, 0xc1, 0xd1, 0xfb, 0xc2, 0xc3, 0x45, 0x41, 0xc5, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send45(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xd0, 0xb5, 0x9e, 0x95, 0xad, 0x5c, 0x65, 0xc9, 0x6b, 0x2e, 0xa, 0x92, 0x9c, 0x1e, 0x8c, 0xae, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send46(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x45, 0xda, 0x98, 0x42, 0x2d, 0x31, 0x1f, 0x90, 0xe6, 0xbb, 0xf, 0xe9, 0xe9, 0xe5, 0x45, 0xd6, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send47(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x7f, 0x1d, 0x2f, 0x37, 0xae, 0xac, 0x57, 0x22, 0x57, 0xe1, 0x4c, 0x12, 0xfd, 0x3a, 0x2b, 0x6e, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send48(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x37, 0x52, 0x14, 0xe, 0xe, 0xbc, 0xa7, 0xa3, 0x8e, 0x34, 0x8d, 0xf, 0x5, 0x8, 0x12, 0xd6, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send49(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x1, 0x31, 0x41, 0x71, 0x5f, 0xb9, 0xb7, 0x6e, 0xf7, 0xf7, 0x17, 0x6, 0xf6, 0xc9, 0x97, 0xe8, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send50(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xff, 0x24, 0xe1, 0xbd, 0x4a, 0x40, 0x6f, 0x7c, 0xc6, 0x84, 0xd0, 0x79, 0x61, 0x18, 0xdc, 0x3c, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send51(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x86, 0xd7, 0x51, 0x4a, 0x34, 0x56, 0x27, 0xa1, 0x4a, 0x61, 0xba, 0xe4, 0xa0, 0x88, 0x68, 0x76, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send52(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xf6, 0x2f, 0xa1, 0x84, 0xec, 0x9a, 0xe2, 0x22, 0x9b, 0x26, 0x78, 0xcc, 0x8b, 0x53, 0x63, 0xca, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send53(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x44, 0xab, 0x59, 0x63, 0x99, 0xfb, 0x62, 0x47, 0xa5, 0x89, 0x72, 0x71, 0x0, 0x26, 0x43, 0x7c, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send54(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x7e, 0xc4, 0xeb, 0x61, 0x5, 0x37, 0x87, 0xf4, 0xe9, 0x2c, 0xd0, 0x45, 0x3c, 0xc4, 0xd, 0xcb, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send55(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xfa, 0xdf, 0x7b, 0x9f, 0x74, 0x18, 0x33, 0x56, 0xbe, 0xe7, 0xdd, 0x34, 0x85, 0x11, 0x27, 0xf0, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send56(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x6, 0x1a, 0xb, 0xb3, 0xd8, 0x31, 0xb4, 0x9a, 0x25, 0xd6, 0xc6, 0x0, 0xee, 0xc6, 0xde, 0xcb, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send57(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xc3, 0x8b, 0x1b, 0xca, 0x33, 0xe6, 0xf4, 0x23, 0xb4, 0x3d, 0xbb, 0x36, 0x4, 0xa9, 0x68, 0x65, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send58(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x2c, 0x15, 0x92, 0x4a, 0xbe, 0xff, 0xd3, 0xfc, 0x9f, 0xca, 0xd2, 0x4, 0x87, 0x51, 0x3d, 0x31, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send59(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x12, 0x9d, 0x4d, 0xaa, 0xdb, 0xcc, 0xa9, 0xe7, 0x2f, 0x94, 0x9f, 0xc0, 0xf4, 0x67, 0xb7, 0xb7, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send60(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xa, 0x55, 0xb6, 0xf8, 0x7, 0x2a, 0xaf, 0x61, 0x72, 0x24, 0x19, 0x8c, 0xf8, 0x83, 0xde, 0x47, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send61(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xad, 0xeb, 0xd9, 0xee, 0x78, 0x2a, 0x9e, 0xe9, 0x3, 0x40, 0x64, 0x98, 0x24, 0x21, 0x6e, 0x9, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send62(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x1, 0xd, 0xc3, 0x92, 0xe8, 0xfb, 0x4d, 0x6, 0x84, 0x91, 0x2e, 0xc1, 0x60, 0xa9, 0xe6, 0xfd, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send63(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x5e, 0x2b, 0x91, 0x3f, 0xc8, 0x5b, 0x9d, 0x45, 0x7a, 0x2b, 0x68, 0x78, 0x83, 0x73, 0x6b, 0x90, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send64(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x58, 0x34, 0xbb, 0xac, 0x95, 0x4c, 0xc1, 0xa0, 0xa4, 0x2, 0xe8, 0x62, 0xc8, 0x18, 0x16, 0xf7, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send65(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x3a, 0xfa, 0x79, 0x14, 0xaa, 0xa9, 0x79, 0x89, 0x14, 0x58, 0xd3, 0xee, 0x43, 0x26, 0x96, 0xf, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send66(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x1b, 0xb1, 0xa5, 0xed, 0x17, 0xe9, 0x81, 0x75, 0x51, 0xbf, 0x85, 0xc4, 0x67, 0x2b, 0xfa, 0xd3, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send67(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xd2, 0x22, 0xb, 0x5, 0xc9, 0x81, 0xa2, 0x59, 0xa9, 0x62, 0x33, 0x99, 0x29, 0xed, 0x8, 0x3e, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send68(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xf2, 0x4b, 0xbf, 0x3c, 0xfb, 0xe6, 0x4f, 0x3a, 0xa6, 0xc8, 0x70, 0xae, 0x23, 0x60, 0xd5, 0xec, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send69(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x2d, 0xa3, 0xcb, 0xbe, 0x93, 0x48, 0x8, 0x6a, 0x38, 0xfa, 0x63, 0x96, 0xc8, 0xba, 0xd2, 0x63, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send70(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x38, 0xb7, 0x94, 0x8d, 0xf, 0x57, 0xfa, 0x37, 0x10, 0x1e, 0xdb, 0xa8, 0x44, 0x61, 0x26, 0x82, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send71(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x8, 0xcc, 0xb2, 0x43, 0x19, 0x26, 0xd1, 0xe2, 0xa4, 0x8f, 0xe4, 0x73, 0x6e, 0xe5, 0x32, 0x1a, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send72(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x4d, 0x1d, 0x6f, 0xa0, 0x89, 0xe, 0xde, 0x4a, 0x1d, 0x9f, 0xa8, 0xc9, 0xf9, 0x97, 0xb9, 0x61, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send73(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x81, 0x2, 0x93, 0x58, 0x85, 0xa0, 0xfa, 0x7b, 0x79, 0x3d, 0x77, 0xae, 0x1a, 0xdb, 0x1d, 0x6c, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send74(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x5e, 0x55, 0x34, 0xed, 0xa5, 0x42, 0xc8, 0x58, 0xa4, 0xcd, 0x43, 0x66, 0x70, 0xf0, 0x30, 0xae, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send75(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x70, 0x1f, 0x4a, 0x70, 0x36, 0x8d, 0xe8, 0x24, 0x4f, 0xac, 0x5c, 0xea, 0xe7, 0xc7, 0x84, 0x9e, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send76(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x85, 0xed, 0xfb, 0xd4, 0x9d, 0x5b, 0x58, 0x9c, 0xe6, 0x2f, 0xa4, 0x5f, 0x89, 0x84, 0x82, 0x54, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send77(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xe3, 0x93, 0xde, 0x54, 0x90, 0xec, 0xc3, 0x81, 0xed, 0x2b, 0xdf, 0xd, 0xb0, 0x2f, 0xb1, 0x18, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send78(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x70, 0xcd, 0x58, 0x77, 0x88, 0xf, 0x8a, 0x67, 0x57, 0x79, 0xc8, 0xbb, 0xf4, 0x43, 0x3f, 0x0, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send79(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x38, 0xd7, 0x93, 0xaa, 0x1e, 0x7c, 0x6d, 0x35, 0xf0, 0x3f, 0x54, 0xbc, 0x78, 0x5d, 0xde, 0xf9, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send80(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xb8, 0xf0, 0x8d, 0x95, 0xc5, 0x85, 0x46, 0x77, 0x7d, 0x59, 0x24, 0x69, 0xe4, 0xc5, 0xce, 0x46, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send81(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x30, 0xd1, 0xe8, 0xe5, 0x41, 0x7e, 0x29, 0x2, 0x61, 0x51, 0x87, 0x37, 0xa7, 0xb, 0x68, 0x6, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send82(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xc6, 0xe2, 0x29, 0xbe, 0x17, 0xfc, 0x41, 0xfc, 0x75, 0xf9, 0x3f, 0xbf, 0x7f, 0x5e, 0x66, 0x38, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send83(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x7e, 0xd4, 0x0, 0xd7, 0xef, 0x20, 0x2f, 0xa5, 0x3c, 0x95, 0xa2, 0xbe, 0x60, 0xf6, 0xf, 0xb9, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send84(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xe4, 0xf6, 0x8b, 0xfe, 0x90, 0xd8, 0xed, 0xa2, 0xd6, 0x9c, 0xd5, 0x8b, 0x29, 0x6e, 0xa4, 0xb1, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send85(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xeb, 0x9d, 0x23, 0x1c, 0x30, 0xe3, 0xd3, 0x8a, 0x1d, 0x8b, 0x56, 0x5f, 0x8c, 0x14, 0x49, 0x35, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send86(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x3f, 0x99, 0x3b, 0xbc, 0x4f, 0x88, 0x13, 0x86, 0xa1, 0x8b, 0x43, 0xe5, 0x3e, 0x68, 0x61, 0xf4, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send87(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x89, 0x4a, 0x6f, 0x52, 0x4b, 0x6d, 0xd2, 0xc7, 0x52, 0xe7, 0x4e, 0x4f, 0x81, 0xb5, 0x32, 0x12, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send88(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xfa, 0xc8, 0x53, 0x3f, 0x49, 0x21, 0x37, 0x2a, 0x63, 0xa3, 0xa6, 0x74, 0x40, 0x96, 0xe9, 0x47, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send89(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xdc, 0xb0, 0xbb, 0x5, 0xb4, 0x1f, 0xfe, 0x5, 0x18, 0x48, 0xeb, 0x12, 0xf4, 0xf5, 0x8d, 0xc2, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send90(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xe5, 0x5b, 0xa2, 0x65, 0x9c, 0xac, 0x69, 0x1d, 0x2a, 0xb3, 0xec, 0x4, 0x8e, 0xd0, 0x62, 0x9b, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send91(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xa0, 0x9b, 0x6d, 0xdb, 0x9, 0x1f, 0x1e, 0xe2, 0x8d, 0x7e, 0xef, 0x33, 0x3, 0xa6, 0x56, 0xcf, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send92(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x96, 0xb3, 0xf6, 0xf, 0x38, 0x84, 0x8c, 0xc4, 0x24, 0x8b, 0xae, 0x79, 0x59, 0xb4, 0x92, 0x97, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send93(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xd3, 0x4c, 0xb6, 0x5c, 0xd3, 0x67, 0x28, 0xb4, 0xbe, 0xad, 0x69, 0x28, 0x56, 0xce, 0x9e, 0xb6, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send94(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xe6, 0x67, 0xd4, 0x85, 0xee, 0x33, 0xb7, 0xf3, 0xa3, 0xf, 0x7b, 0x11, 0xd0, 0x7f, 0xa3, 0x7d, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send95(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0xa3, 0xcf, 0xc3, 0x6c, 0xbb, 0x81, 0x6a, 0x31, 0xc1, 0xd2, 0x43, 0x76, 0xd9, 0x41, 0x78, 0xc8, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send96(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x53, 0x1b, 0x47, 0xbb, 0x47, 0x6c, 0x5d, 0xd5, 0xf6, 0x71, 0x88, 0xc, 0x6b, 0xb2, 0xc4, 0x2e, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send97(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x3d, 0x60, 0x3, 0x2, 0x7d, 0x14, 0x19, 0xd5, 0x4d, 0xb6, 0xcc, 0xd4, 0x69, 0xe7, 0x69, 0x13, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send98(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x43, 0xab, 0x25, 0xbf, 0xe0, 0xe7, 0xe0, 0x54, 0xb8, 0x21, 0xd0, 0xd5, 0x3b, 0x87, 0xec, 0x23, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}
void encrypt_send99(ROPRESPONSE* rr, HANDLE recv_handle) {
	unsigned char ice_key[16] = { 0x4b, 0x6f, 0xd5, 0x10, 0x6b, 0xef, 0x72, 0x58, 0x4, 0x11, 0xfa, 0xf6, 0xdb, 0xb9, 0x9f, 0x92, };
	IceKey ice(2);
	ice.set(ice_key);

	auto h_ntdll = GetModuleHandle(L"ntdll.dll");
	DWORD ProcessDebugPort;
	if (!h_ntdll) {
		exit_with_invalid(rr, recv_handle);
	}

	PFZWQUERYINFORMATIONPROCESS pfZwQueryInformationProcess;
	pfZwQueryInformationProcess = (PFZWQUERYINFORMATIONPROCESS)GetProcAddress(h_ntdll, "ZwQueryInformationProcess");
	pfZwQueryInformationProcess(GetCurrentProcess(), 0x7, &ProcessDebugPort, sizeof(DWORD), 0);
	if (ProcessDebugPort == -1) {
		exit_with_invalid(rr, recv_handle);
	}

	unsigned char respbuf[32];
	unsigned char* origbuf = rr->flag;

	if (IsDebuggerPresent()) exit_with_invalid(rr, recv_handle);

	for (int i = 0; i < 32; i += 8) {
		ice.encrypt(origbuf + i, respbuf + i);
	}

	BOOL debuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
	if (debuggerPresent) {
		exit_with_invalid(rr, recv_handle);
	}

	for (int i = 0; i < 32; i++) {
		origbuf[i] = respbuf[i] ^ ice_key[i % 16];
	}

	WriteFile(recv_handle, rr, sizeof(ROPRESPONSE), NULL, NULL);
}

struct ENCRYPTEDFUNC {
	std::pair<void*, size_t> aes_init_func;
	std::pair<void*, size_t> ropp_main_func;

	ENCRYPTEDFUNC(void* f1, size_t s1, void* f2, size_t s2) {
		this->aes_init_func = { f1, s1 };
		this->ropp_main_func = { f2, s2 };
	}
};

#define INIT_AES_FUNC_SIZE 0x50
#define ROPP_MAIN_FUNC_SIZE 0x310

std::vector<ENCRYPTEDFUNC> funcs = {
	ENCRYPTEDFUNC(init_aes_0, INIT_AES_FUNC_SIZE, encrypt_send0, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_1, INIT_AES_FUNC_SIZE, encrypt_send1, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_2, INIT_AES_FUNC_SIZE, encrypt_send2, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_3, INIT_AES_FUNC_SIZE, encrypt_send3, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_4, INIT_AES_FUNC_SIZE, encrypt_send4, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_5, INIT_AES_FUNC_SIZE, encrypt_send5, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_6, INIT_AES_FUNC_SIZE, encrypt_send6, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_7, INIT_AES_FUNC_SIZE, encrypt_send7, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_8, INIT_AES_FUNC_SIZE, encrypt_send8, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_9, INIT_AES_FUNC_SIZE, encrypt_send9, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_10, INIT_AES_FUNC_SIZE, encrypt_send10, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_11, INIT_AES_FUNC_SIZE, encrypt_send11, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_12, INIT_AES_FUNC_SIZE, encrypt_send12, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_13, INIT_AES_FUNC_SIZE, encrypt_send13, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_14, INIT_AES_FUNC_SIZE, encrypt_send14, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_15, INIT_AES_FUNC_SIZE, encrypt_send15, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_16, INIT_AES_FUNC_SIZE, encrypt_send16, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_17, INIT_AES_FUNC_SIZE, encrypt_send17, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_18, INIT_AES_FUNC_SIZE, encrypt_send18, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_19, INIT_AES_FUNC_SIZE, encrypt_send19, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_20, INIT_AES_FUNC_SIZE, encrypt_send20, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_21, INIT_AES_FUNC_SIZE, encrypt_send21, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_22, INIT_AES_FUNC_SIZE, encrypt_send22, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_23, INIT_AES_FUNC_SIZE, encrypt_send23, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_24, INIT_AES_FUNC_SIZE, encrypt_send24, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_25, INIT_AES_FUNC_SIZE, encrypt_send25, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_26, INIT_AES_FUNC_SIZE, encrypt_send26, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_27, INIT_AES_FUNC_SIZE, encrypt_send27, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_28, INIT_AES_FUNC_SIZE, encrypt_send28, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_29, INIT_AES_FUNC_SIZE, encrypt_send29, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_30, INIT_AES_FUNC_SIZE, encrypt_send30, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_31, INIT_AES_FUNC_SIZE, encrypt_send31, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_32, INIT_AES_FUNC_SIZE, encrypt_send32, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_33, INIT_AES_FUNC_SIZE, encrypt_send33, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_34, INIT_AES_FUNC_SIZE, encrypt_send34, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_35, INIT_AES_FUNC_SIZE, encrypt_send35, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_36, INIT_AES_FUNC_SIZE, encrypt_send36, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_37, INIT_AES_FUNC_SIZE, encrypt_send37, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_38, INIT_AES_FUNC_SIZE, encrypt_send38, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_39, INIT_AES_FUNC_SIZE, encrypt_send39, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_40, INIT_AES_FUNC_SIZE, encrypt_send40, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_41, INIT_AES_FUNC_SIZE, encrypt_send41, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_42, INIT_AES_FUNC_SIZE, encrypt_send42, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_43, INIT_AES_FUNC_SIZE, encrypt_send43, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_44, INIT_AES_FUNC_SIZE, encrypt_send44, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_45, INIT_AES_FUNC_SIZE, encrypt_send45, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_46, INIT_AES_FUNC_SIZE, encrypt_send46, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_47, INIT_AES_FUNC_SIZE, encrypt_send47, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_48, INIT_AES_FUNC_SIZE, encrypt_send48, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_49, INIT_AES_FUNC_SIZE, encrypt_send49, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_50, INIT_AES_FUNC_SIZE, encrypt_send50, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_51, INIT_AES_FUNC_SIZE, encrypt_send51, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_52, INIT_AES_FUNC_SIZE, encrypt_send52, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_53, INIT_AES_FUNC_SIZE, encrypt_send53, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_54, INIT_AES_FUNC_SIZE, encrypt_send54, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_55, INIT_AES_FUNC_SIZE, encrypt_send55, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_56, INIT_AES_FUNC_SIZE, encrypt_send56, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_57, INIT_AES_FUNC_SIZE, encrypt_send57, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_58, INIT_AES_FUNC_SIZE, encrypt_send58, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_59, INIT_AES_FUNC_SIZE, encrypt_send59, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_60, INIT_AES_FUNC_SIZE, encrypt_send60, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_61, INIT_AES_FUNC_SIZE, encrypt_send61, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_62, INIT_AES_FUNC_SIZE, encrypt_send62, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_63, INIT_AES_FUNC_SIZE, encrypt_send63, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_64, INIT_AES_FUNC_SIZE, encrypt_send64, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_65, INIT_AES_FUNC_SIZE, encrypt_send65, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_66, INIT_AES_FUNC_SIZE, encrypt_send66, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_67, INIT_AES_FUNC_SIZE, encrypt_send67, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_68, INIT_AES_FUNC_SIZE, encrypt_send68, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_69, INIT_AES_FUNC_SIZE, encrypt_send69, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_70, INIT_AES_FUNC_SIZE, encrypt_send70, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_71, INIT_AES_FUNC_SIZE, encrypt_send71, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_72, INIT_AES_FUNC_SIZE, encrypt_send72, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_73, INIT_AES_FUNC_SIZE, encrypt_send73, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_74, INIT_AES_FUNC_SIZE, encrypt_send74, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_75, INIT_AES_FUNC_SIZE, encrypt_send75, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_76, INIT_AES_FUNC_SIZE, encrypt_send76, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_77, INIT_AES_FUNC_SIZE, encrypt_send77, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_78, INIT_AES_FUNC_SIZE, encrypt_send78, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_79, INIT_AES_FUNC_SIZE, encrypt_send79, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_80, INIT_AES_FUNC_SIZE, encrypt_send80, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_81, INIT_AES_FUNC_SIZE, encrypt_send81, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_82, INIT_AES_FUNC_SIZE, encrypt_send82, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_83, INIT_AES_FUNC_SIZE, encrypt_send83, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_84, INIT_AES_FUNC_SIZE, encrypt_send84, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_85, INIT_AES_FUNC_SIZE, encrypt_send85, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_86, INIT_AES_FUNC_SIZE, encrypt_send86, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_87, INIT_AES_FUNC_SIZE, encrypt_send87, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_88, INIT_AES_FUNC_SIZE, encrypt_send88, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_89, INIT_AES_FUNC_SIZE, encrypt_send89, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_90, INIT_AES_FUNC_SIZE, encrypt_send90, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_91, INIT_AES_FUNC_SIZE, encrypt_send91, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_92, INIT_AES_FUNC_SIZE, encrypt_send92, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_93, INIT_AES_FUNC_SIZE, encrypt_send93, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_94, INIT_AES_FUNC_SIZE, encrypt_send94, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_95, INIT_AES_FUNC_SIZE, encrypt_send95, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_96, INIT_AES_FUNC_SIZE, encrypt_send96, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_97, INIT_AES_FUNC_SIZE, encrypt_send97, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_98, INIT_AES_FUNC_SIZE, encrypt_send98, ROPP_MAIN_FUNC_SIZE),
	ENCRYPTEDFUNC(init_aes_99, INIT_AES_FUNC_SIZE, encrypt_send99, ROPP_MAIN_FUNC_SIZE)
};

void decrypt_aes(void* func, size_t size, unsigned char* aes_key, unsigned char* aes_iv, ROPRESPONSE* rr, HANDLE recv_handle) {
	DWORD oldProtect;
	VirtualProtect(func, size, PAGE_EXECUTE_READWRITE, &oldProtect);
	unsigned char* buf = (unsigned char*)malloc(size);
	if (!buf) exit_with_invalid(rr, recv_handle);
	plusaes::decrypt_cbc((unsigned char*)func, size, aes_key, 16, (unsigned char(*)[16])aes_iv, buf, size, NULL);
	memcpy(func, buf, size);
	free(buf);
	VirtualProtect(func, size, oldProtect, &oldProtect);
	return;
}

unsigned char cmp_array[32] = { 243, 54, 190, 158, 145, 40, 17, 94, 55, 64, 178, 228, 13, 104, 153, 119, 174, 220, 212, 160, 205, 1, 105, 235, 199, 209, 183, 194, 232, 26, 221, 221 };

int main(int argc, char* argv[]) {

	int depth = 0;
	if (argc > 1) {
		depth = std::stoi(argv[1]);
	}
	std::wstring nxt_pipe_name = PIPE_FILE;
	nxt_pipe_name += std::to_wstring(depth + 1);
	std::wstring now_pipe_name = PIPE_FILE;
	now_pipe_name += std::to_wstring(depth);
	
	ROP rop;
	ROPRESPONSE rop_response;
	STARTUPINFOA si = { sizeof(STARTUPINFOA) };
	PROCESS_INFORMATION pi = {};

	HANDLE recv_handle = recv_ropp(&rop, now_pipe_name.c_str());

	size_t pre_targ = rop.targ;
	
	void (*fp)(ROP*) = depth == 0 ? nullptr : (void (*)(ROP*))funcs[rop.targ].aes_init_func.first;
	void (*fp2)(ROPRESPONSE*, HANDLE) = depth == 0 ? nullptr : (void (*)(ROPRESPONSE*, HANDLE))funcs[rop.targ].ropp_main_func.first;

	if (recv_handle) { // child process, origin is surpassed though
		//std::cout << "Process " << depth << " is working" << '\n';
		//std::cout << "Validate1: " << funcs[rop.targ].ropp_main_func.first << '\n';
		decrypt_aes(funcs[rop.targ].ropp_main_func.first, funcs[rop.targ].ropp_main_func.second, rop.aes_key, rop.aes_iv, &rop_response, recv_handle);
		//std::cout << "Validate2: " << funcs[rop.targ].ropp_main_func.first << '\n';
		//std::cout << "Validate3: " << fp2 << '\n';
		decrypt_aes(funcs[rop.targ].aes_init_func.first, funcs[rop.targ].aes_init_func.second, rop.aes_key, rop.aes_iv, &rop_response, recv_handle);
		//std::cout << "Old Target: " << rop.targ << '\n';
		fp(&rop);
		//std::cout << "New Target: " << rop.targ << '\n';
	}
	else { // origin process
		//std::cout << "Made Origin Process" << '\n';
		unsigned char aes_key[16] = { 98, 200, 159, 214, 247, 124, 34, 110, 152, 170, 242, 103, 107, 244, 59, 211 };
		unsigned char aes_iv[16] = { 170, 218, 13, 23, 78, 116, 38, 84, 52, 134, 168, 181, 66, 119, 171, 177 };
		rop.init(aes_iv, aes_key, 0); // depth, depth, random
	}

	if (depth >= 101 && recv_handle) {
		std::cout << "Long time waiting... Show your input. I'll validate.\n";
		std::string input;
		std::cin >> input;
		if (input.size() != 32) exit_with_invalid(&rop_response, recv_handle);
		for (int i = 0; i < 32; i++) {
			rop_response.flag[i] = input[i];
		}
		exit_with_sending(&rop_response, recv_handle);
	}

	char cmdLine[256];
	sprintf_s(cmdLine, sizeof(cmdLine), "%s %d", argv[0], depth + 1);

	if (CreateProcessA(NULL, cmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
		HANDLE send_handle = send_ropp(&rop, nxt_pipe_name.c_str());
		if (!send_handle) {
			exit_with_invalid(&rop_response, recv_handle);
		}
		if (!ReadFile(send_handle, &rop_response, sizeof(ROPRESPONSE), NULL, NULL)) {
			exit_with_invalid(&rop_response, recv_handle);
		}
		//std::cout << "Response: " << rop_response.invalid << ' ' << pre_targ << ' ' << rop.targ << '\n';
		
		for (int i = 0; i < 32; i++) {
			std::cout << (int)rop_response.flag[i] << ", ";
		}
		std::cout << '\n';
		
		if (rop_response.invalid && depth != 0) exit_with_invalid(&rop_response, recv_handle);
		if (depth != 0) {
			//std::cout << "Validate3: " << fp2 << '\n';
			fp2(&rop_response, recv_handle);
		}

		WaitForSingleObject(pi.hProcess, INFINITE);
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
	}

	if (depth == 0) {
		if (rop_response.invalid) {
WrongThing:
			std::cout << "No, you are wrong." << '\n';
			exit(1);
		}
		if (memcmp(rop_response.flag, cmp_array, 32)) {
			goto WrongThing;
		}
		else {
			std::cout << "Yes, you are right!!" << '\n';
		}
	}

	//std::cout << "Process " << depth << " done\n";
}